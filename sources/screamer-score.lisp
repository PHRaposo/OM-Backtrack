(in-package :om)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; SCREAMER-SCORE

(defmethod! screamer-score ((poly-object poly) 
                                                (domains t)
                                                (score-constraints t)
                                                (force-function t) (random? symbol)) 
  :initvals '(nil nil nil nil t) 
  :indoc '("voice" "screamer-score-domain or list of domains"  "list of screamer-score-constraints" "ordering-force-functions" "t or nil")
  :menuins '((4 (("t" t) ("nil" nil))))
  :doc "SCREAMER-SCORE: this function returns a poly object replacing all pitches by domain notes, retaining all rhythms. 
<INPUT1>: poly object with any number of voices. 
<INPUT2>: score-domain object (generated by screamer-score-domain) or list of domains objects. 
<INPUT3>: score-constraint object (generated by constraint-one-voice, constraint-harmony, constraint-profile or constraint-measure) or list of constraints objects.
<INPUT 4>: screamer ordering and force functions (generated by the force-function).
<INPUT 5>: t for a random solution or nil for a ordered solution." 
  :icon 487 

(declaim (optimize (speed)))

(let* (;(pref-valuation *screamer-valuation*)
         (voices (voices poly-object))
         (all-domains (build-screamer-score-domain voices domains random?))
         (measures-domains (build-measures-domain voices all-domains)))

 (if (screamer-score-constraint-p score-constraints)
     (apply-screamer-score-constraint (get-constraint-parameters score-constraints) all-domains measures-domains)

    (mapcar #'(lambda (constraint)
     (if (null constraint) nil 
         (apply-screamer-score-constraint (get-constraint-parameters constraint) all-domains measures-domains)))
     score-constraints)
   )
;(setf *screamer-valuation* 2)

(print "Timing evaluation of screamer-score...")

(let ((scs-time (list (get-internal-run-time) (get-internal-real-time)))
       (solution
        (s::count-scs-failures (s::one-value ;(s::print-values
         (make-instance 'poly :voices (mapcar #'update-pitches voices
          (first (s::solution all-domains
                    (cond ((equal force-function "static-ordering linear-force") (s::static-ordering #'s::linear-force))
                              ((equal force-function "static-ordering divide-and-conquer-force") (s::static-ordering #'s::divide-and-conquer-force))
                              (t (s::reorder 
                                  (cond ((null (second force-function)) #'s::domain-size)
                                            ((equal (second force-function) "domain-size") #'s::domain-size)   
                                            ((equal (second force-function) "range-size") #'s::range-size)
                                           (t #'s::domain-size))
                                  (cond ((null (third force-function)) #'(lambda (x) (declare (ignore x)) nil))
                                            ((functionp (third force-function)) (third force-function))
                                            ((equal (third force-function) "(< x 1e-6)") #'(lambda (x) (< x 1e-6)))
                                            (t #'(lambda (x) (declare (ignore x)) nil)))
                                  (cond ((null (fourth force-function)) #'<)
                                            ((equal (fourth force-function) ">") #'>)
                                            (t #'<)) 
                                (cond ((null (fifth force-function)) #'s::linear-force) 
                                      ((equal (fifth force-function) "linear-force") #'s::linear-force)   
                                      ((equal (fifth force-function) "divide-and-conquer-force") #'s::divide-and-conquer-force)
                                      (t #'s::linear-force))
                               )))))))))))

(print-scs-time scs-time)
     ;(progn (setf *screamer-valuation* pref-valuation)
                (test-solution solution) ;)    
  )))
  
(defun update-pitches (voice-object solution)
 (make-instance 'voice
      :tree (tree voice-object)
      :tempo (tempo voice-object)
      :legato (legato voice-object)
      :ties (ties voice-object)
      :chords solution))
	  
(defun test-solution (solution)
 (if (or (not (equal (type-of solution) 'poly))
           (null solution))
     (progn (om-message-dialog "UNABLE TO FIND A SOLUTION." ) (om-beep) (om-abort)) 
  solution))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; SCREAMER-SCORE-CONSTRAINTS

(defmethod! constraint-one-voice ((constraint function) (constraint-mode string)
                                                       (voices list)
                                                       (domain string) &optional (percentage-mode "off") percentage) 												  
    :initvals '(nil "list" (0 1) "pitch" "off" 0)
    :indoc '( "<lambda-patch>" "list" "list-of-voice-numbers" "string" "string" "number") 
    :doc "Constraint for one-voice"
    :menuins '((1 (("list" "list") ("n-inputs" "n-inputs") ("car-cdr" "car-cdr")))
                     (3 (
                       ("pitch" "pitch")
                       ("pitch+dur" "pitch+dur")
                       ("pitch+onset" "pitch+onset")
                       ("pitch+dur+onset" "pitch+dur+onset")
                          )
                        )
                    (4 (("off" "off") ("exactly" "exactly") ("less-than" "less-than") ("greater-than" "greater-than")))
                     )                        
    :icon 487
   (let ((constraint-object (make-instance 'score-constraint)))
    (set-constraint-parameters (list "constraint-one-voice" constraint constraint-mode voices percentage-mode percentage domain) constraint-object)
   constraint-object))

(defmethod! constraint-harmony ((constraint function)
                                                     (constraint-mode string)                                                
                                                     (input-mode string) &optional voices (percentage-mode "off") percentage) 												  
    :initvals '(nil "list" "all-voices" nil "off" 0)
    :indoc '( "<lambda-patch>"  "constraint-mode" "input-mode" "list-of-voice-numbers" "string" "number") 
    :doc "Constraint for one-voice"
    :menuins '((1 (("list" "list") ("n-inputs" "n-inputs") ("car-cdr" "car-cdr")))
                     (2 (("all-voices" "all-voices") ("voices-list" "voices-list")))
                     (4 (("off" "off") ("exactly" "exactly") ("less-than" "less-than") ("greater-than" "greater-than"))) )                        
    :icon 487
   (let ((constraint-object (make-instance 'score-constraint)))
    (if (equal input-mode "voices-list")
         (set-constraint-parameters (list "constraint-harmony" constraint constraint-mode "voices-list" voices percentage-mode percentage) constraint-object)
         (set-constraint-parameters (list "constraint-harmony" constraint constraint-mode "all-voices" nil percentage-mode percentage) constraint-object))
 constraint-object)) 

(defmethod! constraint-profile ((bpf-object bpf-lib)
                                                 (voices list) (approx integer) (range string))	
    :initvals '(nil (0) 400 "voice-range")
    :indoc '( "bpf or bpf-lib" "list-of-voice-numbers" "midics" "string") 
    :doc "Constraint profile for voice or voices" 
    :menuins '((3 (("voice-range" "voice-range") ("all" "all"))))                   
    :icon 487
   (let ((constraint (make-instance 'score-constraint)))
      (set-constraint-parameters (list "constraint-profile" bpf-object voices approx range) constraint)
   constraint))

(defmethod! constraint-profile ((bpf-object bpf)
                                                 (voices list) (approx integer)(range string))	
    :initvals '(nil (0) 400 "voice-range")
    :indoc '( "bpf or bpf-lib" "number or list of voice numbers" "midics" "string") 
    :doc "Constraint profile for voice or voices" 
    :menuins '((3 (("voice-range" "voice-range") ("all" "all"))))   	                   
    :icon 487
   (let ((constraint (make-instance 'score-constraint)))
      (set-constraint-parameters (list "constraint-profile" bpf-object voices approx range) constraint)
   constraint))

(defun make-profile-constraint (bpf-lib voices all-domains approx range)
 (let* ((original-bpfs (if (equal (type-of bpf-lib) 'bpf-lib) (bpf-list bpf-lib) (repeat-n bpf-lib (length (first all-domains))))) 
         (pitch-domain (mapcar #'(lambda (x) (mapcar #'first x)) (third all-domains))) ;pitch-variables with rests
         (ratio-domain (om-abs (mapcar #'(lambda (x) (mapcar #'second x)) (third all-domains))))
         (bpfs (mapcar #'scale-bpf-time (posn-match ratio-domain voices) original-bpfs))
        (midics (mapcar #'sort-list (last-elem all-domains))))
(if (equal range "voice-range")
    (midics-profiles-voice-range bpfs voices midics pitch-domain approx)
    (midics-profiles-all bpfs voices midics pitch-domain approx))))

(defun scale-bpf-time (ratios bpf)
 (let* ((bpf-y-points (y-points bpf)) 
        (length-lcm (lcm (length ratios) (length bpf-y-points)))
        (scale-ratios (om-round (om-scale (dx->x (first ratios) ratios) 0 (1- length-lcm)) 0))
        (samples (multiple-value-bind (x y z) (om-sample bpf-y-points length-lcm) (third (list x y z)))))
(simple-bpf-from-list scale-ratios (posn-match samples scale-ratios))))

(defun midics-profiles-voice-range (bpfs voices midics pitch-domain approx)
  (let* ((samples (mapcar #'(lambda (bpf pitch-dom)
                            (multiple-value-bind (x y z) (om-sample (y-points bpf) (length pitch-dom)) 
								                           (third (list x y z)))) 
			      bpfs (posn-match pitch-domain voices)))
        (notes-positions (mapcar #'(lambda (sample midics-list) (om-round (om-scale sample 0 (1- (length midics-list))) 0)) samples (posn-match midics voices)))
        (midic-profile (mapcar #'(lambda (midics-list positions) (posn-match midics-list positions)) (posn-match midics voices) notes-positions)))
(mapcar #'(lambda (vars midics)
 (profile-constraint vars midics approx)) (posn-match pitch-domain voices) midic-profile)))

(defun midics-profiles-all (bpfs voices midics pitch-domain approx)
 (let* ((sample-all (multiple-value-bind (x y z) (om-sample (make-instance 'bpf-lib :bpf-list bpfs) (length (first pitch-domain))) (third (list x y z))))
          (min-max-all-samples (list (list-min (flat sample-all)) (list-max (flat sample-all))))
          (sample-min-max (mapcar #'(lambda (sample) (list (first min-max-all-samples) (list-min sample) (list-max sample) (second min-max-all-samples))) sample-all))
          (all-midics (remove-duplicates (flat midics)))
          (min-max-positions (mapcar #'(lambda (sample) (om-round (butlast (cdr (om-scale sample 0 (1- (length all-midics))))))) sample-min-max))
          (resamples (mapcar #'(lambda (bpf pitch-dom)
                            (multiple-value-bind (x y z) (om-sample (y-points bpf) (length pitch-dom)) 
								                           (third (list x y z)))) 
			      bpfs (posn-match pitch-domain voices)))
          (notes-positions (mapcar #'(lambda (sample min-max-posn) (om-round (om-scale sample (first min-max-posn) (second min-max-posn)))) resamples min-max-positions))
          (midic-profile (mapcar #'(lambda (positions) (posn-match all-midics positions)) notes-positions)))
(mapcar #'(lambda (vars midics)
 (profile-constraint vars midics approx)) (posn-match pitch-domain voices) midic-profile)))

(defun profile-constraint (vars midics-profiles approx)
 (let ((chords? (list-of-listp vars)))
 (mapcar #'(lambda (var midic)
 (cond ((null var) nil)

            (t  (if chords?                       
                 (s::assert! (s::andv (s::>=v (first var) (s::-v midic approx))
                                               (s::<=v (first var) (s::+v midic approx))))  
                     
                 (s::assert! (s::andv (s::>=v var (s::-v midic approx))
                                               (s::<=v var (s::+v midic approx))))))))
 vars midics-profiles)))

(defmethod! bpf-lib-from-poly ((poly-obj poly))
    :initvals '(nil)
    :indoc '( "poly object") 
    :doc "Builds a bpf-lib from a poly object."                    
    :icon 475
(make-instance 'bpf-lib 
  :bpf-list 
  (mapcar #'(lambda (voice)
   (let ((tempo-ms (float (/ 1000 (/ 60 (second (car (tempo voice))))))))
   (simple-bpf-from-list (butlast (dx->x 0 (om* tempo-ms (om-abs (tree2ratio (tree voice))))))
                                    (flat (mapcar #'lmidic (chords voice))))))
   (voices poly-obj))))
 
(defmethod! constraint-measure ((constraints t)
                                                     (measure-number t))	
    :initvals '(nil 0)
    :indoc '( "screamer-score-constraints or list of constraints" "measure number or list of numbers") 
    :doc "Formats the constraint to be applyied to selected measure."                    
    :icon 487
     (let ((constraint-object (make-instance 'score-constraint)))
      (set-constraint-parameters (list "constraint-measure" constraints measure-number) constraint-object)
     constraint-object))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; PERCENTAGE-CONSTRAINT

(defun percentage-constraint-n-inputs (score-constraints voice-domain)
  (let* ((chords? (list-of-listp voice-domain))
           (voice-length (length voice-domain))
           (fn-inputs-length (length (function-lambda-list (second score-constraints))))
           (apply-length (if (= 1 fn-inputs-length) 
                                     voice-length 
                                    (- voice-length (1- fn-inputs-length))))
          (percent (om-round (* (if (equal (first score-constraints) "constraint-one-voice") 
                                                  (sixth score-constraints) 
                                                  (seventh score-constraints)) 
                                          (/ apply-length 100)) 
                          0))
          (percent-cs-mode (if (equal (first score-constraints) "constraint-one-voice")
                                           (fifth score-constraints)
                                           (sixth score-constraints)))
          (splitted-list (if (and (= 1 fn-inputs-length) (not chords?)) 
                                 (flat voice-domain)
                                 (split-domain-list1 voice-length fn-inputs-length voice-domain))))
     (cond ((equal percent-cs-mode "exactly")
                (let* ((test (if (and (= 1 fn-inputs-length) (not chords?))
                                 (?::mapcarv #'(lambda (x) (apply (second score-constraints) (list x))) splitted-list)
                                 (?::mapcarv #'(lambda (x) (apply (second score-constraints) x)) splitted-list)))
                         (truesv (om?::sumv (mapcar #'s::count-truesv test))))
                (s::assert! (s::=v truesv percent))))

                ((equal percent-cs-mode "less-than")
                 (let* ((test (if (and (= 1 fn-inputs-length) (not chords?))
                                  (?::mapcarv #'(lambda (x) (apply (second score-constraints) (list x))) splitted-list)
                                  (?::mapcarv #'(lambda (x) (apply (second score-constraints) x)) splitted-list)))
                         (truesv (om?::sumv (mapcar #'s::count-truesv test))))
                (s::assert! (s::<v truesv percent))))

                ((equal percent-cs-mode "greater-than")
                 (let* ((test (if (and (= 1 fn-inputs-length) (not chords?)) 
                                  (?::mapcarv #'(lambda (x) (apply (second score-constraints) (list x))) splitted-list)
                                  (?::mapcarv #'(lambda (x) (apply (second score-constraints) x)) splitted-list)))
                         (truesv (om?::sumv (mapcar #'s::count-truesv test))))
                 (if (= percent apply-length) 
                     (s::assert! (s::=v truesv percent))
                     (s::assert! (s::>v truesv percent)))))

                (t (progn (om-message-dialog "Unknown percentage constraint mode") (om-abort)))
      )
    )
 )

(defun split-domain-list1 (list-length n-inputs voice-domain);==> N-INPUTS ((0 1) (1 2) (2 3) ...)
 (let* ((posn (loop for x from 0 to (- list-length n-inputs)
          for y = (arithm-ser x (+ x (1- n-inputs)) 1)
 collect y)))
(posn-match voice-domain posn)))

(defun percentage-constraint-n-inputs-harmony (score-constraints voice-domain)
  (let* ((voice-length (length voice-domain))
           (fn-inputs-length (length (function-lambda-list (second score-constraints))))
           (apply-length (if (= 1 fn-inputs-length) 
                                     voice-length 
                                    (- voice-length (1- fn-inputs-length))))
          (percent (om-round (* (seventh score-constraints) (/ apply-length 100)) 0))
          (percent-cs-mode (sixth score-constraints))
          (splitted-list (split-domain-list1 voice-length fn-inputs-length voice-domain)))

     (cond ((equal percent-cs-mode "exactly")
                (let* ((test (?::mapcarv #'(lambda (x) (apply (second score-constraints) x)) splitted-list))
                         (truesv (om?::sumv (mapcar #'s::count-truesv test))))
                (s::assert! (s::=v truesv percent))))

                ((equal percent-cs-mode "less-than")
                 (let* ((test (?::mapcarv #'(lambda (x) (apply (second score-constraints) x)) splitted-list))
                         (truesv (om?::sumv (mapcar #'s::count-truesv test))))
                (s::assert! (s::<v truesv percent))))

                ((equal percent-cs-mode "greater-than")
                 (let* ((test (?::mapcarv #'(lambda (x) (apply (second score-constraints) x)) splitted-list))
                         (truesv (om?::sumv (mapcar #'s::count-truesv test))))
                 (if (= percent apply-length) 
                     (s::assert! (s::=v truesv percent))
                     (s::assert! (s::>v truesv percent)))))

                (t (progn (om-message-dialog "Unknown percentage constraint mode") (om-abort)))
      )
    )
 )

(defun percentage-constraint-harmony (score-constraints voice-domain)
   (cond ((equal (fourth score-constraints) "all-voices")
              (percentage-constraint-n-inputs-harmony score-constraints voice-domain))

             ((equal (fourth score-constraints) "voices-list")
               (if (list-of-listp (fifth score-constraints))
                   (let ((voices-chords (loop for positions in (fifth score-constraints)
                                                    collect (mapcar #'(lambda (chords-domain) (posn-match chords-domain positions)) voice-domain))))
                   (mapcar #'(lambda (vars) 
                                     (percentage-constraint-n-inputs-harmony score-constraints vars)) 
                    voices-chords))

              (percentage-constraint-n-inputs-harmony score-constraints (mapcar #'(lambda (chords-domain) (posn-match chords-domain (fifth score-constraints))) voice-domain))))

         (t (progn (om-message-dialog "UNKNOWN CONSTRAINT OPTION") (om-abort)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun apply-percentage-constraint (score-constraints voice-domain)
 (cond 
 ((equal (third score-constraints) "list")
  (progn (om-message-dialog "The percentage constraint ONLY works in constraint-mode <N-INPUTS>.") (om-abort)))

 ((equal (third score-constraints) "n-inputs")
  (if (equal (first score-constraints) "constraint-harmony")
      (percentage-constraint-harmony score-constraints voice-domain)
  (percentage-constraint-n-inputs score-constraints voice-domain)))

 ((equal (third score-constraints) "car-cdr")
  (progn (om-message-dialog "The percentage constraint ONLY works in constraint-mode <N-INPUTS>.") (om-abort)))

 (t nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ANOTHER VERSION OF 
;;; PERCENTAGE-CONSTRAINT 
;;;USING SCREAMER-PLUS FUNCTIONS 
;;; EXACTLYV, AT-LEASTV AND AT-MOSTV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|
(defun percentage-constraint-n-inputs-one-voice (score-constraints voice-domain)
  (let* ((voice-length (length voice-domain))
           (fn-inputs-length (length (function-lambda-list (second score-constraints))))
           (apply-length (if (= 1 fn-inputs-length) 
                                     voice-length 
                                    (- voice-length (1- fn-inputs-length))))
          (percent  (om-round (* (sixth score-constraints) (/ apply-length 100)) 0))
          (splitted-list (split-domain-list1 voice-length fn-inputs-length voice-domain)))
   (s::assert!
     (cond ((equal (fifth score-constraints) "exactly")
                (?::exactlyv percent (eval `#'(lambda (x) (apply ,(?::constraint-fn (second score-constraints)) x))) splitted-list))

                ((equal (fifth score-constraints) "less-than")
                 (s::notv (?::at-leastv percent  (eval `#'(lambda (x) (apply ,(?::constraint-fn (second score-constraints)) x))) splitted-list)))

                ((equal (fifth score-constraints) "greater-than")
                  (s::notv (?::at-mostv percent (eval `#'(lambda (x) (apply ,(?::constraint-fn (second score-constraints)) x))) splitted-list)))

                (t (progn (om-message-dialog "Unknown percentage constraint mode") (om-abort))))
   )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;IN PROGRESS

(defun percentage-constraint-one-voice-car-cdr (score-constraints voice-domain)
 (let* ((voice-length (length voice-domain))
          (apply-length (1- voice-length))
          (percent (om-round (* (sixth score-constraints) (/ apply-length 100)) 0))
          (splitted-list (reverse (split-domain-list2 apply-length voice-domain))))

     (cond ((equal (fifth score-constraints) "exactly")
                 (let* ((test (?::mapcarv #'(lambda (x) (funcall (second score-constraints) (first x) (second x))) splitted-list))
                         (trues (apply #'s::+v (list (apply #'s::count-truesv test)))))
                  (s::assert! (?::ifv (s::=v trues percent) t nil))))

                ((equal (fifth score-constraints) "less-than")
                 (let* ((test (?::mapcarv #'(lambda (x) (funcall (second score-constraints) (first x) (second x))) splitted-list))
                         (trues (apply #'s::+v (list (apply #'s::count-truesv test)))))
                  (s::assert! (?::ifv (s::<v trues percent) t nil))))

                ((equal (fifth score-constraints) "greater-than")
                 (let* ((test (?::mapcarv #'(lambda (x) (funcall (second score-constraints) (first x) (second x))) splitted-list))
                         (trues (apply #'s::+v (list (apply #'s::count-truesv test)))))
                  (s::assert! (?::ifv (s::>v trues percent) t nil))))

                (t (progn (om-message-dialog "Unknown percentage constraint mode") (om-abort))))))

(defun split-domain-list2 (apply-length voice-domain);==> CARD-CDR ((0 (1 2 3 4 5)) (1 (2 3 4 5)) (2 (3 4 5)) ...)
 (let* ((posn (loop for x from 0 to (1- apply-length)
          for y = (list x (arithm-ser (1+ x) apply-length 1))
 collect y)))
 (posn-match voice-domain posn)))

(defun split-domain-list3 (list-length voice-domain);==> GROWING LIST ((0) (0 1) (0 1 2) ...)
 (let* ((posn (loop for x from 0 to (1- list-length)
          for y = (arithm-ser 0 x 1)
 collect y)))
 (posn-match voice-domain posn)))
|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; APPLY-SCREAMER-SCORE-CONSTRAINT

(defun apply-screamer-score-constraint (score-constraints all-domains measures-domains)
(if (null score-constraints) nil
 (cond 
  ((equal (first score-constraints) "constraint-one-voice")
   (let ((voices-domain 
          (posn-match 
           (cond 
            ((equal (last-elem score-constraints) "pitch")  (first all-domains))
            ((equal (last-elem score-constraints) "pitch+dur")  (third all-domains))
            ((equal (last-elem score-constraints) "pitch+onset")  (fourth all-domains))
            ((equal (last-elem score-constraints) "pitch+dur+onset")  (fifth all-domains))
            (t (progn (om-message-dialog "Unknown option for constraint-one-voice") (om-abort))))
           (fourth score-constraints))))
   (if (not (equal (fifth score-constraints) "off"))
        (if (= 1 (length voices-domain))
            (apply-percentage-constraint score-constraints (first voices-domain))
           (mapcar #'(lambda (voice-domain) 
                             (apply-percentage-constraint score-constraints voice-domain)) 
            voices-domain))      
    (mapcar #'(lambda (voice) 
           (cond ((equal (third score-constraints) "list") (apply (second score-constraints) (list voice)))

                     ((equal (third score-constraints) "n-inputs")

                      (apply-contv (second score-constraints) "list" "n-inputs" voice))

                     (t (apply-contv (second score-constraints) "list" "car-cdr" voice))))

       voices-domain))))

  ((equal (first score-constraints) "constraint-harmony")
   (let ((domain (second all-domains)))
    (if (not (equal (sixth score-constraints) "off"))
         (apply-percentage-constraint score-constraints domain))

   (cond 
     ((equal (fourth score-constraints) "all-voices")
          (cond 
         ((equal (third score-constraints) "list")
                      (apply (second score-constraints) (list domain)))

                      ((equal (third score-constraints) "n-inputs")

                      (apply-contv  (second score-constraints) "list" "n-inputs" domain))

                      (t (apply-contv  (second score-constraints) "list" "car-cdr"  domain))))

          ((equal (fourth score-constraints) "voices-list")
            (if (list-of-listp (fifth score-constraints))
                (let ((voices-chords (loop for positions in (fifth score-constraints)
                                                 collect (mapcar #'(lambda (chords-domain) (posn-match chords-domain positions)) domain))))
                        (mapcar #'(lambda (vars) 
                         (cond 
                        ((equal (third score-constraints) "list")
                                    (apply (second score-constraints) (list vars)))

                                    ((equal (third score-constraints) "n-inputs")

                                     (apply-contv  (second score-constraints) "list" "n-inputs" vars))

                                      (t (apply-contv  (second score-constraints) "list" "car-cdr"  vars))))
                        voices-chords))

                          (cond 
                         ((equal (third score-constraints) "list")
                                     (apply (second score-constraints) (list (mapcar #'(lambda (chords-domain) (posn-match chords-domain (fifth score-constraints))) domain))))

                                     ((equal (third score-constraints) "n-inputs")
									 
                                       (apply-contv  (second score-constraints) "list" "n-inputs"  (mapcar #'(lambda (chords-domain) (posn-match chords-domain (fifth score-constraints))) domain)))

                                     (t (apply-contv  (second score-constraints) "list" "car-cdr"  (mapcar #'(lambda (chords-domain) (posn-match chords-domain (fifth score-constraints))) domain))))))

         (t (progn (om-message-dialog "UNKNOWN CONSTRAINT OPTION") (om-abort))))))

  ((equal (first score-constraints) "constraint-profile")
    (make-profile-constraint (second score-constraints) (third score-constraints) all-domains (fourth score-constraints) (fifth score-constraints)))

  ((equal (first score-constraints) "constraint-measure")
    (if (screamer-score-constraint-p (second score-constraints))
        (if (numberp (third score-constraints))
        (apply-one-constraint-to-measure (third score-constraints) (get-constraint-parameters (second score-constraints)) measures-domains)
        (mapcar #'(lambda (measure-number) 
                          (apply-one-constraint-to-measure measure-number (get-constraint-parameters (second score-constraints)) measures-domains))
         (third score-constraints)))
       
        (mapcar #'(lambda (constraint)
         (cond ((null constraint) nil)
                    ((numberp (third score-constraints))
                    (apply-one-constraint-to-measure (third score-constraints) (get-constraint-parameters constraint) measures-domains))
                  ((listp (third score-constraints))
        (mapcar #'(lambda (measure-number) 
                          (apply-one-constraint-to-measure measure-number (get-constraint-parameters constraint) measures-domains))
         (third score-constraints)))
                  (t nil)))
        (second score-constraints)))
     )

(t (progn (om-message-dialog "UNKNOWN CONSTRAINT MEASURE OPTION") (om-abort))))))

(defun apply-one-constraint-to-measure (measure-number score-constraints measure-domains)
(if (null score-constraints) nil
 (cond 
  ((equal (first score-constraints) "constraint-one-voice")
   (let* ((voices-pitch 
           (posn-match 
            (cond 
            ((equal (last-elem score-constraints) "pitch")  (first measure-domains))
            ((equal (last-elem score-constraints) "pitch+dur")  (third measure-domains))
            ((equal (last-elem score-constraints) "pitch+onset")  (fourth measure-domains))
            ((equal (last-elem score-constraints) "pitch+dur+onset")  (fifth measure-domains))
            (t (progn (om-message-dialog "Unknown constraint-one-voice option") (om-abort))))
           (fourth score-constraints)))
          (voices-domain (mapcar #'(lambda (x) (posn-match x measure-number))
                                     voices-pitch)))
     (if (not (equal (fifth score-constraints) "off"))
          (if (= 1 (length voices-domain))
              (apply-percentage-constraint score-constraints (first voices-domain))
             (mapcar #'(lambda (voice-domain) 
                               (apply-percentage-constraint score-constraints voice-domain)) 
              voices-domain))  
    (mapcar #'(lambda  (voice) 
          (cond ((equal (third score-constraints) "list")
                      (apply-contv (second score-constraints) "list" "off" voice))

                      ((equal (third score-constraints) "n-inputs")
                      (apply-contv  (second score-constraints) "list" "n-inputs" voice))

                      (t (apply-contv  (second score-constraints) "list" "car-cdr" voice))))
     voices-domain))))

  ((equal (first score-constraints) "constraint-harmony")
   (let ((domain (posn-match (second measure-domains) measure-number)))
    (if (not (equal (sixth score-constraints) "off"))
        (apply-percentage-constraint score-constraints domain)
   (cond 
     ((equal (fourth score-constraints) "all-voices")
          (cond 
         ((equal (third score-constraints) "list")
                      (apply (second score-constraints) (list domain)))

                      ((equal (third score-constraints) "n-inputs")
                      (apply-contv  (second score-constraints) "list" "n-inputs"  domain))

                      (t (apply-contv  (second score-constraints) "list" "car-cdr"  domain))))

          ((equal (fourth score-constraints) "voices-list")
            (if (list-of-listp (fifth score-constraints))
                (let ((voices-chords (loop for positions in (fifth score-constraints)
                                                 collect (mapcar #'(lambda (chords-domain) (posn-match chords-domain positions)) domain))))
                        (mapcar #'(lambda (vars) 
                         (cond 
                        ((equal (third score-constraints) "list")
                                    (apply (second score-constraints) (list vars)))

                                    ((equal (third score-constraints) "n-inputs")
                                     (apply-contv  (second score-constraints) "list" "n-inputs" vars))

                                      (t (apply-contv  (second score-constraints) "list" "car-cdr"  vars))))
                        voices-chords))

                          (cond 
                         ((equal (third score-constraints) "list")
                                     (apply (second score-constraints) (list (mapcar #'(lambda (chords-domain) (posn-match chords-domain (fifth score-constraints))) domain))))

                                     ((equal (third score-constraints) "n-inputs")
                                       (apply-contv  (second score-constraints) "list" "n-inputs"  (mapcar #'(lambda (chords-domain) (posn-match chords-domain (fifth score-constraints))) domain)))

                                     (t (apply-contv  (second score-constraints) "list" "car-cdr"  (mapcar #'(lambda (chords-domain) (posn-match chords-domain (fifth score-constraints))) domain))))))

         (t (progn (om-message-dialog "UNKNOWN OPTION") (om-abort)))))))

  ((equal (first score-constraints) "constraint-profile")
   (let* ((voices-pitch (first measure-domains))
            (voices-measures (mapcar #'(lambda (x) (posn-match x measure-number))
                                           voices-pitch))
           (measure-pitch-dur (third measure-domains))
           (voices-pitch-dur (mapcar #'(lambda (x) (posn-match x measure-number))
                                           measure-pitch-dur)))                         
 (make-profile-constraint (second score-constraints) 
                                         (third score-constraints) 
                                         (list voices-measures '(nil) voices-pitch-dur (last-elem measure-domains))
                                         (fourth score-constraints) 
                                         (fifth score-constraints))))
  (t nil))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; DOMAIN

(defun build-screamer-score-domain (voices domains random?)
 (let* ((pitch-domains (pitch-domains voices (if (screamer-score-domain-p domains)
		                                                          (list (get-domain-parameters domains))
												   (mapcar #'(lambda (score-domain)
												     (get-domain-parameters score-domain)) domains))));==> chord-objects for locked-voices and list of midics for variables
         (midics-domain (mapcar #'(lambda (x) (if (chord-p (first x)) (flat (mapcar #'lmidic x)) (second x))) pitch-domains))
         (pitch-durs-domain (domain-pitch-dur voices pitch-domains random?))  ;==> list-of-list with pitch/dur
         (ratios-domain (mapcar #'(lambda (x) (mapcar #'second x)) pitch-durs-domain))  ;==> list-of-lists of ratios
         (pitch-variables (mapcar #'(lambda (x) (mapcar #'first x)) pitch-durs-domain))  ;==> list-of-lists of pitches [midics for locked-voices, nil for rests and screamer (a-random-member-ofv domain) for open-voices]
         (onsets-domain (mapcar #'ratios2onsets ratios-domain)) ;==> list-of-lists of onsets 
         (notes-positions (mapcar #'ratios2notes-posn ratios-domain)) ;==> list-of-lists of notes positions 
         (all-onsets (sort-list (remove-duplicates (flat onsets-domain)))) ;==> all-onsets from all-voices
         (notes-positions-in-onsets-list  (mapcar #'(lambda (input)
                                                          (posn-in-onsets-list input all-onsets)) (mapcar #'list onsets-domain notes-positions))) ;;;=> list-of-lists of positions for each pitch in onsets lists, repeating long notes.
        (pitch-variables-all-onsets (mapcar #'posn-match pitch-variables notes-positions-in-onsets-list)) ;==> list of pitches repeating long notes.
        (rest-positions (mapcar #'get-rest-places voices)) ;==> rests positions 
        (pitch-positions-without-rests (mapcar #'remove-rest-posn rest-positions notes-positions)) ;==> only notes positions
        (pitch-variables-without-rests (mapcar #'posn-match pitch-variables pitch-positions-without-rests)) ;==> only pitch/var without rests
        (all-chords (mapcar #'flat 
                            (remove-if #'(lambda (x) 
                                                                   (or (not (some #'s::variable? (flat x)))
                                                                                (some #'null (remove nil (flat x)))))             
                           (mat-trans pitch-variables-all-onsets))))
        (pitch-onset-domain (mapcar #'(lambda (x y) (mapcar #'(lambda (input1 input2) (if (listp input1) (x-append (list input1) input2) (x-append input1 input2))) x y)) pitch-variables onsets-domain))
        (pitch-dur-onset-domain (mapcar #'(lambda (x y) (mapcar #' x-append x y)) pitch-durs-domain onsets-domain)))
 (list pitch-variables-without-rests all-chords pitch-durs-domain pitch-onset-domain pitch-dur-onset-domain pitch-variables-all-onsets midics-domain)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ==> ALL-DOMAINS <== ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
; FIRST -> ONLY PITCH
;SECOND -> CHORDS 
;THIRD -> PITCH/DURS 
;FOURTH -> PITCH/ONSETS
;FIFTH -> PITCH/DUR/ONSET
;SIXTH -> PITCH-VARS-ALL-ONSETS (FOR MEASURES)
;EIGHTH -> MIDICS DOMAIN (ALWAYS LAST-ELEM ==> FOR PROFILE CONSTRAINT)
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;  =================   ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod! screamer-score-domain ((domain list)
                                   (type string) &optional n-notes)												  
    :initvals '((6000 6200 6400 6500 6700 6900 7100 7200) "notes" 3)
    :indoc '( "midics-list"  "domain-type" "number or list") 
    :doc "Formats the domain (list of midics) according to the selected type (notes or chords)."
    :menuins '((1 (("notes" "notes") ("chords" "chords"))))                        
    :icon 487
(let ((domain-object (make-instance 'score-domain)))
(if (equal type "notes")
    (set-domain-parameters (list type domain) domain-object)
   (set-domain-parameters (list type domain n-notes) domain-object))
domain-object))

(defun locked-voice? (voice)
 (let ((voice-chords (remove-duplicates (flat (mapcar #'lmidic (chords voice))))))
 (not (and (= 6000 (first voice-chords))
           (= 1 (length voice-chords))))))
		   
(defun positions (input-list input-elem)
  (let ((index 0) res)
    (dolist (n input-list)
      (if (equal input-elem n)  (push index res)) ;modified to equal
      (setq index (1+ index)))
    (nreverse res))) 

(defun pitch-domains (voices domains)
(let* ((locked-voices-pitch (mapcar #'(lambda (x) 
                                    (if (locked-voice? x) 
                                        (chords x) t)) voices))
         (open-voices-posn (positions locked-voices-pitch t)))
(subs-posn locked-voices-pitch open-voices-posn domains)))

(defun pitch-dur-locked (ratio chord)
 (if (< ratio 0)
 (x-append (list nil) ratio)
 (x-append (lmidic chord) ratio)))

(defun pitch-dur-vars (ratio domain random?)
 (if (< ratio 0)
 (x-append (list nil) ratio)
 (cond 
  ((equal (first domain) "notes")
    (if random? 
       (x-append (om?::a-random-member-ofv (second domain)) ratio)
       (x-append (om?::a-member-ofv (second domain)) ratio)))
  ((equal (first domain) "chords")
    (x-append (om?::list-of-chords-inv (list (third domain)) (second domain) random?) ratio))
 (t (progn (om-message-dialog "UNKNOWN DOMAIN TYPE") (om-abort))))
))

(defun pitch-dur-chords (ratios domain chord-l random? accumul)
(if chord-l

 (let ((one-result 
        (if (< (first ratios) 0)
            (x-append (list nil) (first ratios))
             (x-append (om?::list-of-chords-inv (list (first chord-l)) domain random?) (first ratios)))))

   (if (null (first one-result))

       (pitch-dur-chords (cdr ratios) domain chord-l random? (x-append (list one-result) accumul)) 

       (pitch-dur-chords (cdr ratios) domain (cdr chord-l) random? (x-append (list one-result) accumul))))

 (reverse accumul))) 

(defun domain-pitch-dur (voices pitch-domains random?)
(mapcar #'(lambda (voice pitch-dom)
 (if (locked-voice? voice)
     (mapcar #'pitch-dur-locked (tree2ratio (tree voice)) pitch-dom)
(if (equal (first pitch-dom) "chords") 
     (if (listp (third (first pitch-domains))) 
         (let* ((ratios (tree2ratio (tree voice)))
                  (n-chords (length (remove-if #'(lambda (x) (< x 0)) ratios)))
                  (chords-correct-length (flat (group-list (third (first pitch-domains)) (list n-chords) 'circular))))
          (pitch-dur-chords ratios (second (first pitch-domains)) chords-correct-length random? nil))           
     (mapcar #'(lambda (input) 
      (pitch-dur-vars input pitch-dom random?)) (tree2ratio (tree voice))))

     (mapcar #'(lambda (input) 
      (pitch-dur-vars input pitch-dom random?)) (tree2ratio (tree voice))))
    ))
 voices pitch-domains))

(defun build-measures-domain (voices all-domains)
 (let* ((measures (mapcar #'get-measures voices))
          (measures-matrix (if (list-of-listp measures) (mat-trans measures) measures))
          (notes-length-by-measure (mat-trans (mapcar #'(lambda (m-mat) 
                                                      (if (list-of-listp measures) (mapcar #'(lambda (x) (length (flat (mapcar #'lmidic (chords x))))) m-mat) 
                                                          (length (lmidic (chords m-mat)))))
                                                    measures-matrix)))
          (pitch-domains (mapcar #'(lambda (notes-domain notes-length) (group-list notes-domain notes-length 'linear))  (first all-domains) notes-length-by-measure))
          (pitch-dur-domains (mapcar #'(lambda (notes-domain notes-length) (group-list notes-domain notes-length 'linear))  (third all-domains) notes-length-by-measure))
          (pitch-onset-domains (mapcar #'(lambda (notes-domain notes-length) (group-list notes-domain notes-length 'linear))  (fourth all-domains) notes-length-by-measure))
          (pitch-dur-onset-domains (mapcar #'(lambda (notes-domain notes-length) (group-list notes-domain notes-length 'linear))  (fifth all-domains) notes-length-by-measure))
          (chords-length-by-measure (mapcar #'(lambda (x) (length (remove-duplicates (flat  x))))
                                                       (mat-trans (loop for part in pitch-onset-domains
                                                                                  for x = (loop for measure in part 
                                                                                                      collect (mapcar #'second measure))
                                                                                 collect x))))
        (chords-all-onsets (group-list (mat-trans (sixth all-domains)) chords-length-by-measure 'linear))
        (chords-domains (loop for measure in chords-all-onsets
                                             for chords = (mapcar #'flat (remove-if #'(lambda (x) 
                                                                                        (or (not (some #'s::variable? (flat x)))
                                                                                             (some #'null (remove nil (flat x))))) 
                                                                                         measure))
                                            collect chords))
        (midics-domain (last-elem all-domains)))
(list pitch-domains chords-domains pitch-dur-domains pitch-onset-domains pitch-dur-onset-domains midics-domain)))

(defun measure-tree2ratio (mesure)
 (let* ((signature (car mesure))
          (vals (cadr mesure))
          (ratios (mesure-ratios vals)))
          (om/
           (om* ratios (car signature))
           (cadr signature))))

(defun get-measure-rest-places (measure)
 (let ((tree (list '? (list (tree measure)))))
  (get-rest-places tree)))

(defun ratios2onsets (ratios)
(butlast (dx->x 0 (om-abs ratios))))

(defun ratios2notes-posn (ratios) 
(arithm-ser 0 (1- (length ratios)) 1))

(defun posn-in-onsets-list (voice-onsets-posn all-onsets)
(posn-in-onsets-list-internal voice-onsets-posn all-onsets nil))
 
(defun posn-in-onsets-list-internal (voice-onsets-posn all-onsets accumul)
(if all-onsets
   (cond 
   ((= 1 (length (second voice-onsets-posn)) )
    (posn-in-onsets-list-internal voice-onsets-posn
                                                 (cdr all-onsets) 
                                                 (x-append (first (second voice-onsets-posn)) accumul)))

   ((< (first all-onsets) (second (first voice-onsets-posn)) )
    (posn-in-onsets-list-internal voice-onsets-posn
                                                 (cdr all-onsets) 
                                                 (x-append (first (second voice-onsets-posn)) accumul)))

  ((= (first all-onsets) (second (first voice-onsets-posn)) )
     (posn-in-onsets-list-internal (x-append (list (cdr (first voice-onsets-posn)))
                                                                  (list (cdr (second voice-onsets-posn))))
                                                 (cdr all-onsets)
                                                 (x-append (second (second voice-onsets-posn)) accumul))))  

(reverse accumul)))

(defun remove-rest-posn (rest-places positions)
 (remove-if #'(lambda (x) (member x rest-places)) positions))
