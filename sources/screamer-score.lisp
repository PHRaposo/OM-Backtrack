(in-package :om)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; SCREAMER-SCORE

(defmethod! screamer-score ((poly-object poly) 
                                                (domains t)
                                                (score-constraints t)
                                                (force-function t) (random? symbol) (mcs-approx integer) &optional strategy) 
  :initvals '(nil nil nil nil t 2 :gfc) 
  :indoc '("voice" "screamer-score-domain or list of domains"  "list of screamer-score-constraints" "ordering-force-functions" "t or nil" "integer" "strategy")
  :menuins '((4 (("t" t) ("nil" nil))) (5 (("2" 2) ("4" 4) ("8" 8) ("16" 16))) (6 ((":gfc" :gfc) (":ac" :ac))))
  :doc "SCREAMER-SCORE: this function returns a poly object replacing all pitches by domain notes, retaining all rhythms. 
<INPUT1>: poly object with any number of voices. 
<INPUT2>: score-domain object (generated by screamer-score-domain) or list of domains objects. 
<INPUT3>: score-constraint object (generated by constraint-one-voice, constraint-harmony, constraint-profile or constraint-measure) or list of constraints objects.
<INPUT 4>: screamer ordering and force functions (generated by the force-function).
<INPUT 5>: t for a random solution or nil for a ordered solution.
<INPUT 6 = OPTIONAL> Midicents approximation (2 for semitone, 4 for quarter-tones, etc...).
<KEY>: STRATEGY = :gfc for Generalized Forward Checking and :ac for Arc Consistency." 
  :icon 487 
   
 (if strategy (setf s::*strategy* strategy) 
                   (setf s::*strategy* :gfc))

 (setf *p-variables* nil)
				   
 (print "Timing evaluation of screamer-score...")

(let* ((scs-time (list (get-internal-run-time) (get-internal-real-time)))
         (voices (voices poly-object))
         (all-domains (build-screamer-score-domain voices domains mcs-approx random?))
         (measures-domains (build-measures-domain voices all-domains)))

    (if (screamer-score-constraint-p score-constraints)
       (apply-screamer-score-constraint (get-constraint-parameters score-constraints) all-domains measures-domains)
      
       (mapcar #'(lambda (constraint)
                         (if (null constraint) 
                              nil 
                             (apply-screamer-score-constraint (get-constraint-parameters constraint) all-domains measures-domains)))
         score-constraints))
		 
 (let ((solution (screamer-score-solution (append (list *p-variables*) all-domains) force-function)))
   
  (setf *p-variables* nil) 
  (print-scs-time scs-time)
  (test-solution solution voices) 	       
 )))

(defun screamer-score-solution (domains force)
 (let ((force-function force)
        (all-domains domains))
  (s::count-scs-failures 
   (block one-value
   (s::for-effects
   (return-from one-value 
  (second
   (s::solution all-domains
   (cond ((equal force-function "static-ordering linear-force") (s::static-ordering #'s::linear-force))
         ((equal force-function "static-ordering divide-and-conquer-force") (s::static-ordering #'s::divide-and-conquer-force))
         ((equal force-function "static-ordering random-force") (s::static-ordering #'om?::random-force))
             (t (s::reorder 
                 (cond ((null (second force-function)) #'s::domain-size)  
                           ((functionp (second force-function)) (second force-function))
                           ((equal (second force-function) "domain-size") #'s::domain-size)   
                           ((equal (second force-function) "range-size") #'s::range-size)                     
                           (t #'s::domain-size))
                (cond ((null (third force-function)) #'(lambda (x) (declare (ignore x)) nil))
                          ((functionp (third force-function)) (third force-function))
                          ((equal (third force-function) "(< x 1e-6)") #'(lambda (x) (< x 1e-6)))
                          (t #'(lambda (x) (declare (ignore x)) nil)))
               (cond ((null (fourth force-function)) #'<)
                         ((functionp (fourth force-function)) (fourth force-function))
                         ((equal (fourth force-function) ">") #'>)
                         (t #'<)) 
              (cond ((null (fifth force-function)) #'s::linear-force)
                        ((equal (fifth force-function) "linear-force") #'s::linear-force)   
                        ((equal (fifth force-function) "divide-and-conquer-force") #'s::divide-and-conquer-force)
                        ((equal (fifth force-function) "random-force") #'om?::random-force)
                        (t #'s::linear-force))))))
       )))))))

(defun update-pitches (voice-object solution)
 (make-instance 'voice
      :tree (tree voice-object)
      :tempo (tempo voice-object)
      :legato (legato voice-object)
      :ties (ties voice-object)
      :chords solution))
	  
(defun test-solution (solution voices)
 (if (null solution)
     (progn (om-message-dialog "UNABLE TO FIND A SOLUTION." ) (om-beep) (om-abort)) 
  (make-instance 'poly :voices (mapcar #'update-pitches voices solution))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; SCREAMER-SCORE-CONSTRAINTS

(defmethod! constraint-one-voice ((constraint function) (constraint-mode string)
                                                       (voices list)
                                                       (domain string) &optional (percentage-mode "off") percentage) 												  
    :initvals '(nil "list" (0 1) "pitch" "off" 0)
    :indoc '( "<lambda-patch>" "list" "list-of-voice-numbers" "string" "string" "number") 
    :doc "Constraint for one-voice"
    :menuins '((1 (("list" "list") ("n-inputs" "n-inputs") ("car-cdr" "car-cdr")))
                     (3 (
                       ("pitch" "pitch")
                       ("pitch+dur" "pitch+dur")
                       ("pitch+onset" "pitch+onset")
                       ("pitch+dur+onset" "pitch+dur+onset")
                          )
                        )
                    (4 (("off" "off") ("exactly" "exactly") ("less-than" "less-than") ("greater-than" "greater-than")))
                     )                        
    :icon 487
   (let ((constraint-object (make-instance 'score-constraint))
          (compiled-constraint (fdefinition (compile-screamer-constraint constraint))))
    (set-constraint-parameters (list "constraint-one-voice" compiled-constraint constraint-mode voices percentage-mode percentage domain) constraint-object)
   constraint-object))

(defmethod! constraint-harmony ((constraint function) ;INCLUDE DOMAIN OPTIONS (PITCH - PITCH/DUR - PITCH/DUR/ONSET AS THIRD ARGUMENT)
                                                     (constraint-mode string)                                                
                                                     (input-mode string) 
													 (beats string) &optional voices (percentage-mode "off") percentage) 												  
    :initvals '(nil "list" "all-voices" "all" nil "off" 0)
    :indoc '( "<lambda-patch>"  "constraint-mode" "input-mode" "beats-option" "list-of-voice-numbers" "string" "number") 
    :doc "Constraint for one-voice"
    :menuins '((1 (("list" "list") ("n-inputs" "n-inputs") ("car-cdr" "car-cdr")))
                     (2 (("all-voices" "all-voices") ("voices-list" "voices-list")))
                     ;(3 (("pitch" "pitch")("pitch+dur" "pitch+dur")("pitch+dur+onset" "pitch+dur+onset")));==> NOT IMPLEMENTED
                     (3 (("all" "all") ("on-beat" "on-beat") ("off-beat" "off-beat") ("1st-beat" "1st-beat"))) ;==> SHOULD BE CHANGED TO 4					 
                     (5 (("off" "off") ("exactly" "exactly") ("less-than" "less-than") ("greater-than" "greater-than"))) ) ;==> CHANGED TO 5                   
    :icon 487
   (let ((constraint-object (make-instance 'score-constraint))
          (compiled-constraint (fdefinition (compile-screamer-constraint constraint))))
    (if (equal input-mode "voices-list")
         (set-constraint-parameters (list "constraint-harmony" compiled-constraint constraint-mode "voices-list" voices beats percentage-mode percentage) constraint-object)
         (set-constraint-parameters (list "constraint-harmony" compiled-constraint constraint-mode "all-voices" nil beats percentage-mode percentage) constraint-object))
 constraint-object)) 

(defmethod! constraint-profile ((bpf-object bpf-lib)
                                                 (voices list) (approx integer) (range string))	
    :initvals '(nil (0) 400 "voice-range")
    :indoc '( "bpf or bpf-lib" "list-of-voice-numbers" "midics" "string") 
    :doc "Constraint profile for voice or voices" 
    :menuins '((3 (("voice-range" "voice-range") ("all" "all"))))                   
    :icon 487
   (let ((constraint (make-instance 'score-constraint)))
      (set-constraint-parameters (list "constraint-profile" bpf-object voices approx range) constraint)
   constraint))

(defmethod! constraint-profile ((bpf-object bpf)
                                                 (voices list) (approx integer)(range string))	
    :initvals '(nil (0) 400 "voice-range")
    :indoc '( "bpf or bpf-lib" "number or list of voice numbers" "midics" "string or list") 
    :doc "Constraint profile for voice or voices" 
    :menuins '((3 (("voice-range" "voice-range") ("all" "all"))))   	                   
    :icon 487
   (let ((constraint (make-instance 'score-constraint)))
      (set-constraint-parameters (list "constraint-profile" bpf-object voices approx range) constraint)
   constraint))
   
(defmethod! constraint-profile ((bpf-object bpf)
                                                (voices list) (approx integer)(range list))	
   :initvals '(nil (0) 400 (2100 10800))
   :indoc '( "bpf or bpf-lib" "number or list of voice numbers" "midics" "string or list") 
   :doc "Constraint profile for voice or voices" 
   :menuins '((3 (("voice-range" "voice-range") ("all" "all"))))   	                   
   :icon 487
  (let ((constraint (make-instance 'score-constraint)))
     (set-constraint-parameters (list "constraint-profile" bpf-object voices approx range) constraint)
  constraint))

(defun make-profile-constraint (bpf-lib voices all-domains approx range)
 (let* ((original-bpfs (if (equal (type-of bpf-lib) 'bpf-lib) (bpf-list bpf-lib) (repeat-n bpf-lib (length (first all-domains))))) 
         (pitch-domain (mapcar #'(lambda (x) (mapcar #'first x)) (third all-domains))) ;pitch-variables with rests
         (ratio-domain (om-abs (mapcar #'(lambda (x) (mapcar #'second x)) (third all-domains))))
         (bpfs (mapcar #'scale-bpf-time (posn-match ratio-domain voices) original-bpfs))
        (midics (mapcar #'sort-list (last-elem all-domains))))
 (if (listp range)
     (let ((new-midics (mapcar #'(lambda (midics-list) 
		                          (remove-if-not #'(lambda (n) 
									                (and (>= n (first range))
													     (<= n (second range))))
									midics-list))
						midics)))
		(midics-profiles-voice-range bpfs voices new-midics pitch-domain approx))
		
  (if (equal range "voice-range")
      (midics-profiles-voice-range bpfs voices midics pitch-domain approx)
      (midics-profiles-all bpfs voices midics pitch-domain approx)
   )
  )
 )
)

(defun scale-bpf-time (ratios bpf)
 (let* ((bpf-y-points (y-points bpf)) 
        (length-lcm (lcm (length ratios) (length bpf-y-points)))
        (scale-ratios (om-round (om-scale (dx->x (first ratios) ratios) 0 (1- length-lcm)) 0))
        (samples (multiple-value-bind (x y z) (om-sample bpf-y-points length-lcm) (third (list x y z)))))
(simple-bpf-from-list scale-ratios (posn-match samples scale-ratios))))

(defun midics-profiles-voice-range (bpfs voices midics pitch-domain approx)
  (let* ((samples (mapcar #'(lambda (bpf pitch-dom)
                            (multiple-value-bind (x y z) (om-sample (y-points bpf) (length pitch-dom)) 
								                           (third (list x y z)))) 
			      bpfs (posn-match pitch-domain voices)))
        (notes-positions (mapcar #'(lambda (sample midics-list) (om-round (om-scale sample 0 (1- (length midics-list))) 0)) samples (posn-match midics voices)))
        (midic-profile (mapcar #'(lambda (midics-list positions) (posn-match midics-list positions)) (posn-match midics voices) notes-positions)))
(mapcar #'(lambda (vars midics)
 (profile-constraint vars midics approx)) (posn-match pitch-domain voices) midic-profile)))

(defun midics-profiles-all (bpfs voices midics pitch-domain approx)
 (let* ((sample-all (multiple-value-bind (x y z) (om-sample (make-instance 'bpf-lib :bpf-list bpfs) (length (first pitch-domain))) (third (list x y z))))
          (min-max-all-samples (list (list-min (flat sample-all)) (list-max (flat sample-all))))
          (sample-min-max (mapcar #'(lambda (sample) (list (first min-max-all-samples) (list-min sample) (list-max sample) (second min-max-all-samples))) sample-all))
          (all-midics (remove-duplicates (flat midics)))
          (min-max-positions (mapcar #'(lambda (sample) (om-round (butlast (cdr (om-scale sample 0 (1- (length all-midics))))))) sample-min-max))
          (resamples (mapcar #'(lambda (bpf pitch-dom)
                            (multiple-value-bind (x y z) (om-sample (y-points bpf) (length pitch-dom)) 
								                           (third (list x y z)))) 
			      bpfs (posn-match pitch-domain voices)))
          (notes-positions (mapcar #'(lambda (sample min-max-posn) (om-round (om-scale sample (first min-max-posn) (second min-max-posn)))) resamples min-max-positions))
          (midic-profile (mapcar #'(lambda (positions) (posn-match all-midics positions)) notes-positions)))
(mapcar #'(lambda (vars midics)
 (profile-constraint vars midics approx)) (posn-match pitch-domain voices) midic-profile)))

(defun profile-constraint (vars midics-profiles approx)
 (let ((chords? (list-of-listp vars)))
 (mapcar #'(lambda (var midic)
 (cond ((null var) nil)

            (t  (if chords?                       
                (s::assert! (s::andv (s::>=v (first var) (s::-v midic approx))
                                               (s::<=v (first var) (s::+v midic approx))))
                     
                (s::assert! (s::andv (s::>=v var (s::-v midic approx))
                                               (s::<=v var (s::+v midic approx))))))))
 vars midics-profiles)))

(defmethod! bpf-lib-from-poly ((poly-obj poly))
    :initvals '(nil)
    :indoc '( "poly object") 
    :doc "Builds a bpf-lib from a poly object."                    
    :icon 475
(make-instance 'bpf-lib 
  :bpf-list 
  (mapcar #'(lambda (voice)
   (let ((tempo-ms (float (/ 1000 (/ 60 (second (car (tempo voice))))))))
   (simple-bpf-from-list (butlast (dx->x 0 (om* tempo-ms (om-abs (tree2ratio (tree voice))))))
                                    (flat (mapcar #'lmidic (chords voice))))))
   (voices poly-obj))))
 
(defmethod! constraint-measure ((constraints t)
                                                     (measure-number t))	
    :initvals '(nil 0)
    :indoc '( "screamer-score-constraints or list of constraints" "measure number or list of numbers") 
    :doc "Formats the constraint to be applyied to selected measure."                    
    :icon 487
     (let ((constraint-object (make-instance 'score-constraint)))
      (set-constraint-parameters (list "constraint-measure" constraints measure-number) constraint-object)
     constraint-object))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; PERCENTAGE-CONSTRAINT

(defun percentage-constraint-n-inputs (score-constraints voice-domain)
  (let* ((chords? (list-of-listp voice-domain))
           (voice-length (length voice-domain))
           (fn-inputs-length (length (function-lambda-list (second score-constraints))))
           (apply-length (if (= 1 fn-inputs-length) 
                                     voice-length 
                                    (- voice-length (1- fn-inputs-length))))
          (percent (om-round (* (if (equal (first score-constraints) "constraint-one-voice") 
                                                  (sixth score-constraints) 
                                                  (eighth score-constraints)) 
                                          (/ apply-length 100)) 
                          0))
          (percent-cs-mode (if (equal (first score-constraints) "constraint-one-voice")
                                           (fifth score-constraints)
                                           (seventh score-constraints)))
          (splitted-list (if (and (= 1 fn-inputs-length) (not chords?)) 
                                 (flat voice-domain)
                                 (split-domain-list1 voice-length fn-inputs-length voice-domain))))
     (cond ((equal percent-cs-mode "exactly")
                (let* ((test (if (and (= 1 fn-inputs-length) (not chords?))
                                 (?::mapcarv #'(lambda (x) (apply (second score-constraints) (list x))) splitted-list)
                                 (?::mapcarv #'(lambda (x) (apply (second score-constraints) x)) splitted-list)))
                         (truesv (om?::sumv (mapcar #'s::count-truesv test))))
                (s::assert! (s::=v truesv percent)) (list test truesv) ))

                ((equal percent-cs-mode "less-than")
                 (let* ((test (if (and (= 1 fn-inputs-length) (not chords?))
                                  (?::mapcarv #'(lambda (x) (apply (second score-constraints) (list x))) splitted-list)
                                  (?::mapcarv #'(lambda (x) (apply (second score-constraints) x)) splitted-list)))
                         (truesv (om?::sumv (mapcar #'s::count-truesv test))))
                (s::assert! (s::<v truesv percent)) (list test truesv) ))

                ((equal percent-cs-mode "greater-than")
                 (let* ((test (if (and (= 1 fn-inputs-length) (not chords?)) 
                                  (?::mapcarv #'(lambda (x) (apply (second score-constraints) (list x))) splitted-list)
                                  (?::mapcarv #'(lambda (x) (apply (second score-constraints) x)) splitted-list)))
                         (truesv (om?::sumv (mapcar #'s::count-truesv test))))
                 (if (= percent apply-length) 
                     (s::assert! (s::=v truesv percent))
                     (s::assert! (s::>v truesv percent)))
			     (list test truesv) ))

                (t (progn (om-message-dialog "Unknown percentage constraint mode") (om-abort)))
      )
    )
 )

(defun split-domain-list1 (list-length n-inputs voice-domain);==> N-INPUTS ((0 1) (1 2) (2 3) ...)
 (let* ((posn (loop for x from 0 to (- list-length n-inputs)
          for y = (arithm-ser x (+ x (1- n-inputs)) 1)
 collect y)))
(posn-match voice-domain posn)))

(defun percentage-constraint-n-inputs-harmony (score-constraints voice-domain)
  (let* ((voice-length (length voice-domain))
           (fn-inputs-length (length (function-lambda-list (second score-constraints))))
           (apply-length (if (= 1 fn-inputs-length) 
                                     voice-length 
                                    (- voice-length (1- fn-inputs-length))))
          (percent (om-round (* (eighth score-constraints) (/ apply-length 100)) 0))
          (percent-cs-mode (seventh score-constraints))
          (splitted-list (split-domain-list1 voice-length fn-inputs-length voice-domain)))

     (cond ((equal percent-cs-mode "exactly")
                (let* ((test (?::mapcarv #'(lambda (x) (apply (second score-constraints) x)) splitted-list))
                         (truesv (om?::sumv (mapcar #'s::count-truesv test))))
                (s::assert! (s::=v truesv percent)) (list test truesv) ))

                ((equal percent-cs-mode "less-than")
                 (let* ((test (?::mapcarv #'(lambda (x) (apply (second score-constraints) x)) splitted-list))
                         (truesv (om?::sumv (mapcar #'s::count-truesv test))))
                (s::assert! (s::<v truesv percent)) (list test truesv)))

                ((equal percent-cs-mode "greater-than")
                 (let* ((test (?::mapcarv #'(lambda (x) (apply (second score-constraints) x)) splitted-list))
                         (truesv (om?::sumv (mapcar #'s::count-truesv test))))
                 (if (= percent apply-length) 
                     (s::assert! (s::=v truesv percent))
                     (s::assert! (s::>v truesv percent)))
				 (list test truesv) ))

                (t (progn (om-message-dialog "Unknown percentage constraint mode") (om-abort)))
      )
    )
 )

(defun percentage-constraint-harmony (score-constraints voice-domain)
   (cond ((equal (fourth score-constraints) "all-voices")
              (percentage-constraint-n-inputs-harmony score-constraints voice-domain))

             ((equal (fourth score-constraints) "voices-list")
               (if (list-of-listp (fifth score-constraints))
                   (let ((voices-chords (loop for positions in (fifth score-constraints)
                                                    collect (mapcar #'(lambda (chords-domain) (posn-match chords-domain positions)) voice-domain))))
                   (mapcar #'(lambda (vars) 
                                     (percentage-constraint-n-inputs-harmony score-constraints vars)) 
                    voices-chords))

              (percentage-constraint-n-inputs-harmony score-constraints (mapcar #'(lambda (chords-domain) (posn-match chords-domain (fifth score-constraints))) voice-domain))))

         (t (progn (om-message-dialog "UNKNOWN CONSTRAINT OPTION") (om-abort)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun apply-percentage-constraint (score-constraints voice-domain)
 (cond 
 ((equal (third score-constraints) "list")
  (progn (om-message-dialog "The percentage constraint ONLY works in constraint-mode <N-INPUTS>.") (om-abort)))

 ((equal (third score-constraints) "n-inputs")
  (if (equal (first score-constraints) "constraint-harmony")
      (percentage-constraint-harmony score-constraints voice-domain)
  (percentage-constraint-n-inputs score-constraints voice-domain)))

 ((equal (third score-constraints) "car-cdr")
  (progn (om-message-dialog "The percentage constraint ONLY works in constraint-mode <N-INPUTS>.") (om-abort)))

 (t nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ANOTHER VERSION OF 
;;; PERCENTAGE-CONSTRAINT 
;;;USING SCREAMER-PLUS FUNCTIONS 
;;; EXACTLYV, AT-LEASTV AND AT-MOSTV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|
(defun percentage-constraint-n-inputs-one-voice (score-constraints voice-domain)
  (let* ((voice-length (length voice-domain))
           (fn-inputs-length (length (function-lambda-list (second score-constraints))))
           (apply-length (if (= 1 fn-inputs-length) 
                                     voice-length 
                                    (- voice-length (1- fn-inputs-length))))
          (percent  (om-round (* (eighth score-constraints) (/ apply-length 100)) 0))
          (splitted-list (split-domain-list1 voice-length fn-inputs-length voice-domain)))
   (s::assert!
     (cond ((equal (seventh score-constraints) "exactly")
                (?::exactlyv percent (eval `#'(lambda (x) (apply ,(?::constraint-fn (second score-constraints)) x))) splitted-list))

                ((equal (seventh score-constraints) "less-than")
                 (s::notv (?::at-leastv percent  (eval `#'(lambda (x) (apply ,(?::constraint-fn (second score-constraints)) x))) splitted-list)))

                ((equal (seventh score-constraints) "greater-than")
                  (s::notv (?::at-mostv percent (eval `#'(lambda (x) (apply ,(?::constraint-fn (second score-constraints)) x))) splitted-list)))

                (t (progn (om-message-dialog "Unknown percentage constraint mode") (om-abort))))
   )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;IN PROGRESS

(defun percentage-constraint-one-voice-car-cdr (score-constraints voice-domain)
 (let* ((voice-length (length voice-domain))
          (apply-length (1- voice-length))
          (percent (om-round (* (eighth score-constraints) (/ apply-length 100)) 0))
          (splitted-list (reverse (split-domain-list2 apply-length voice-domain))))

     (cond ((equal (seventh score-constraints) "exactly")
                 (let* ((test (?::mapcarv #'(lambda (x) (funcall (second score-constraints) (first x) (second x))) splitted-list))
                         (trues (apply #'s::+v (list (apply #'s::count-truesv test)))))
                  (s::assert! (?::ifv (s::=v trues percent) t nil))))

                ((equal (seventh score-constraints) "less-than")
                 (let* ((test (?::mapcarv #'(lambda (x) (funcall (second score-constraints) (first x) (second x))) splitted-list))
                         (trues (apply #'s::+v (list (apply #'s::count-truesv test)))))
                  (s::assert! (?::ifv (s::<v trues percent) t nil))))

                ((equal (seventh score-constraints) "greater-than")
                 (let* ((test (?::mapcarv #'(lambda (x) (funcall (second score-constraints) (first x) (second x))) splitted-list))
                         (trues (apply #'s::+v (list (apply #'s::count-truesv test)))))
                  (s::assert! (?::ifv (s::>v trues percent) t nil))))

                (t (progn (om-message-dialog "Unknown percentage constraint mode") (om-abort))))))

(defun split-domain-list2 (apply-length voice-domain);==> CARD-CDR ((0 (1 2 3 4 5)) (1 (2 3 4 5)) (2 (3 4 5)) ...)
 (let* ((posn (loop for x from 0 to (1- apply-length)
          for y = (list x (arithm-ser (1+ x) apply-length 1))
 collect y)))
 (posn-match voice-domain posn)))

(defun split-domain-list3 (list-length voice-domain);==> GROWING LIST ((0) (0 1) (0 1 2) ...)
 (let* ((posn (loop for x from 0 to (1- list-length)
          for y = (arithm-ser 0 x 1)
 collect y)))
 (posn-match voice-domain posn)))
|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; APPLY-SCREAMER-SCORE-CONSTRAINT

(defun apply-screamer-score-constraint (score-constraints all-domains measures-domains)
(if (null score-constraints) nil
 (cond 
  ((equal (first score-constraints) "constraint-one-voice")
   (let ((voices-domain 
          (posn-match 
           (cond 
            ((equal (last-elem score-constraints) "pitch")  (first all-domains))
            ((equal (last-elem score-constraints) "pitch+dur")  (third all-domains))
            ((equal (last-elem score-constraints) "pitch+onset")  (fourth all-domains))
            ((equal (last-elem score-constraints) "pitch+dur+onset")  (fifth all-domains))
            (t (progn (om-message-dialog "Unknown option for constraint-one-voice") (om-abort))))
           (fourth score-constraints))))
   (if (not (equal (fifth score-constraints) "off"))
        (if (= 1 (length voices-domain))
            (apply-percentage-constraint score-constraints (first voices-domain))
           (mapcar #'(lambda (voice-domain) 
                             (apply-percentage-constraint score-constraints voice-domain)) 
            voices-domain))      
    (mapcar #'(lambda (voice) 
           (cond ((equal (third score-constraints) "list") (apply (second score-constraints) (list voice)))

                     ((equal (third score-constraints) "n-inputs")

                      (apply-contv (second score-constraints) "list" "n-inputs" voice))

                     (t (apply-contv (second score-constraints) "list" "car-cdr" voice))))

       voices-domain))))

  ((equal (first score-constraints) "constraint-harmony")
   (let ((domain (cond ((equal (sixth score-constraints) "all") (second all-domains))
   					   ((equal (sixth score-constraints) "on-beat") (seventh all-domains))
   					   ((equal (sixth score-constraints) "off-beat") (eighth all-domains))	
   					   ((equal (sixth score-constraints) "1st-beat") (ninth all-domains))
					   (t (progn (om-message-dialog "UNKNOWN BEAT OPTION.") (om-abort)))							   				   
				  )))
    (if (not (equal (seventh score-constraints) "off"))
         (apply-percentage-constraint score-constraints domain))

   (cond 
     ((equal (fourth score-constraints) "all-voices")
          (cond 
         ((equal (third score-constraints) "list")
                      (apply (second score-constraints) (list domain)))

                      ((equal (third score-constraints) "n-inputs")

                      (apply-contv  (second score-constraints) "list" "n-inputs" domain))

                      (t (apply-contv  (second score-constraints) "list" "car-cdr"  domain))))

          ((equal (fourth score-constraints) "voices-list")
            (if (list-of-listp (fifth score-constraints))
                (let ((voices-chords (loop for positions in (fifth score-constraints)
                                                 collect (mapcar #'(lambda (chords-domain) (posn-match chords-domain positions)) domain))))
                        (mapcar #'(lambda (vars) 
                         (cond 
                        ((equal (third score-constraints) "list")
                                    (apply (second score-constraints) (list vars)))

                                    ((equal (third score-constraints) "n-inputs")

                                     (apply-contv  (second score-constraints) "list" "n-inputs" vars))

                                      (t (apply-contv  (second score-constraints) "list" "car-cdr"  vars))))
                        voices-chords))

                          (cond 
                         ((equal (third score-constraints) "list")
                                     (apply (second score-constraints) (list (mapcar #'(lambda (chords-domain) (posn-match chords-domain (fifth score-constraints))) domain))))

                                     ((equal (third score-constraints) "n-inputs")
									 
                                       (apply-contv  (second score-constraints) "list" "n-inputs"  (mapcar #'(lambda (chords-domain) (posn-match chords-domain (fifth score-constraints))) domain)))

                                     (t (apply-contv  (second score-constraints) "list" "car-cdr"  (mapcar #'(lambda (chords-domain) (posn-match chords-domain (fifth score-constraints))) domain))))))

         (t (progn (om-message-dialog "UNKNOWN CONSTRAINT OPTION") (om-abort))))))

  ((equal (first score-constraints) "constraint-profile")
    (make-profile-constraint (second score-constraints) (third score-constraints) all-domains (fourth score-constraints) (fifth score-constraints)))

  ((equal (first score-constraints) "constraint-measure")
    (if (screamer-score-constraint-p (second score-constraints))
        (if (numberp (third score-constraints))
        (apply-one-constraint-to-measure (third score-constraints) (get-constraint-parameters (second score-constraints)) measures-domains)
        (mapcar #'(lambda (measure-number) 
                          (apply-one-constraint-to-measure measure-number (get-constraint-parameters (second score-constraints)) measures-domains))
         (third score-constraints)))
       
        (mapcar #'(lambda (constraint)
         (cond ((null constraint) nil)
                    ((numberp (third score-constraints))
                    (apply-one-constraint-to-measure (third score-constraints) (get-constraint-parameters constraint) measures-domains))
                  ((listp (third score-constraints))
        (mapcar #'(lambda (measure-number) 
                          (apply-one-constraint-to-measure measure-number (get-constraint-parameters constraint) measures-domains))
         (third score-constraints)))
                  (t nil)))
        (second score-constraints)))
     )

(t (progn (om-message-dialog "UNKNOWN CONSTRAINT MEASURE OPTION") (om-abort))))))

(defun apply-one-constraint-to-measure (measure-number score-constraints measure-domains)
(if (null score-constraints) nil
 (cond 
  ((equal (first score-constraints) "constraint-one-voice")
   (let* ((voices-pitch 
           (posn-match 
            (cond 
            ((equal (last-elem score-constraints) "pitch")  (first measure-domains))
            ((equal (last-elem score-constraints) "pitch+dur")  (third measure-domains))
            ((equal (last-elem score-constraints) "pitch+onset")  (fourth measure-domains))
            ((equal (last-elem score-constraints) "pitch+dur+onset")  (fifth measure-domains))
            (t (progn (om-message-dialog "Unknown constraint-one-voice option") (om-abort))))
           (fourth score-constraints)))
          (voices-domain (mapcar #'(lambda (x) (posn-match x measure-number))
                                     voices-pitch)))
     (if (not (equal (fifth score-constraints) "off"))
          (if (= 1 (length voices-domain))
              (apply-percentage-constraint score-constraints (first voices-domain))
             (mapcar #'(lambda (voice-domain) 
                               (apply-percentage-constraint score-constraints voice-domain)) 
              voices-domain))  
    (mapcar #'(lambda  (voice) 
          (cond ((equal (third score-constraints) "list")
                      (apply-contv (second score-constraints) "list" "off" voice))

                      ((equal (third score-constraints) "n-inputs")
                      (apply-contv  (second score-constraints) "list" "n-inputs" voice))

                      (t (apply-contv  (second score-constraints) "list" "car-cdr" voice))))
     voices-domain))))

  ((equal (first score-constraints) "constraint-harmony")
   (let ((domain (cond ((not (equal "all" (sixth score-constraints)))
                        (progn (om-message-dialog "Currently the CONSTRAINT-MEASURE only works in ALL beats mode.") (om-abort)))
						(t (posn-match (second measure-domains) measure-number)))))
    (if (not (equal (seventh score-constraints) "off"))
        (apply-percentage-constraint score-constraints domain)
   (cond 
     ((equal (fourth score-constraints) "all-voices")
          (cond 
         ((equal (third score-constraints) "list")
                      (apply (second score-constraints) (list domain)))

                      ((equal (third score-constraints) "n-inputs")
                      (apply-contv  (second score-constraints) "list" "n-inputs"  domain))

                      (t (apply-contv  (second score-constraints) "list" "car-cdr"  domain))))

          ((equal (fourth score-constraints) "voices-list")
            (if (list-of-listp (fifth score-constraints))
                (let ((voices-chords (loop for positions in (fifth score-constraints)
                                                 collect (mapcar #'(lambda (chords-domain) (posn-match chords-domain positions)) domain))))
                        (mapcar #'(lambda (vars) 
                         (cond 
                        ((equal (third score-constraints) "list")
                                    (apply (second score-constraints) (list vars)))

                                    ((equal (third score-constraints) "n-inputs")
                                     (apply-contv  (second score-constraints) "list" "n-inputs" vars))

                                      (t (apply-contv  (second score-constraints) "list" "car-cdr"  vars))))
                        voices-chords))

                          (cond 
                         ((equal (third score-constraints) "list")
                                     (apply (second score-constraints) (list (mapcar #'(lambda (chords-domain) (posn-match chords-domain (fifth score-constraints))) domain))))

                                     ((equal (third score-constraints) "n-inputs")
                                       (apply-contv  (second score-constraints) "list" "n-inputs"  (mapcar #'(lambda (chords-domain) (posn-match chords-domain (fifth score-constraints))) domain)))

                                     (t (apply-contv  (second score-constraints) "list" "car-cdr"  (mapcar #'(lambda (chords-domain) (posn-match chords-domain (fifth score-constraints))) domain))))))

         (t (progn (om-message-dialog "UNKNOWN OPTION") (om-abort)))))))

  ((equal (first score-constraints) "constraint-profile")
   (let* ((voices-pitch (first measure-domains))
            (voices-measures (mapcar #'(lambda (x) (posn-match x measure-number))
                                           voices-pitch))
           (measure-pitch-dur (third measure-domains))
           (voices-pitch-dur (mapcar #'(lambda (x) (posn-match x measure-number))
                                           measure-pitch-dur)))                         
 (make-profile-constraint (second score-constraints) 
                                         (third score-constraints) 
                                         (list voices-measures '(nil) voices-pitch-dur (last-elem measure-domains))
                                         (fourth score-constraints) 
                                         (fifth score-constraints))))
  (t nil))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; DOMAIN

(defun build-screamer-score-domain (voices domains mcs-approx random?)
 (let* ((pitch-domains (pitch-domains voices (if (screamer-score-domain-p domains)
		                                                          (list (get-domain-parameters domains))
												   (mapcar #'(lambda (score-domain)
												     (get-domain-parameters score-domain)) domains))));==> chord-objects for locked-voices and list of midics for variables
         (midics-domain (mapcar #'(lambda (x) (if (chord-p (first x)) (flat (mapcar #'lmidic x)) (second x))) pitch-domains))
         (pitch-durs-domain (domain-pitch-dur voices pitch-domains mcs-approx random?))  ;==> list-of-list with pitch/dur
         (ratios-domain (mapcar #'(lambda (x) (mapcar #'second x)) pitch-durs-domain))  ;==> list-of-lists of ratios
         (pitch-variables (mapcar #'(lambda (x) (mapcar #'first x)) pitch-durs-domain))  ;==> list-of-lists of pitches [midics for locked-voices, nil for rests and screamer (a-random-member-ofv domain) for open-voices]
         (onsets-domain (mapcar #'ratios2onsets ratios-domain)) ;==> list-of-lists of onsets 
         (notes-positions (mapcar #'ratios2notes-posn ratios-domain)) ;==> list-of-lists of notes positions 
         (all-onsets (sort-list (remove-duplicates (flat onsets-domain)))) ;==> all-onsets from all-voices
         (notes-positions-in-onsets-list  (mapcar #'(lambda (input)
                                                          (posn-in-onsets-list input all-onsets)) (mapcar #'list onsets-domain notes-positions))) ;;;=> list-of-lists of positions for each pitch in onsets lists, repeating long notes.
        (pitch-variables-all-onsets (mapcar #'posn-match pitch-variables notes-positions-in-onsets-list)) ;==> list of pitches repeating long notes.
        (beats-and-offbeats (get-beats-offbeats voices all-onsets pitch-variables-all-onsets)) ;==> FIRST (ON-BEATS) ==> SECOND (OFF-BEATS) ==> THIRD (FIRST BEATS)
        (chords-on-beats (mapcar #'flat ;==> list of chords on-beats
                            (remove-if #'(lambda (x) 
                                                                   (or (not (some #'s::variable? (flat x)))
                                                                                (some #'null (remove nil (flat x)))))             
                           (first beats-and-offbeats))))
        (chords-off-beats (mapcar #'flat ;==> list of chords off-beats
                            (remove-if #'(lambda (x) 
                                                                   (or (not (some #'s::variable? (flat x)))
                                                                                (some #'null (remove nil (flat x)))))             
                          (second beats-and-offbeats))))
		(chords-first-beats (mapcar #'flat ;==> list of chords first beats
                            (remove-if #'(lambda (x) 
                                                                   (or (not (some #'s::variable? (flat x)))
                                                                                (some #'null (remove nil (flat x)))))             
                          (third beats-and-offbeats))))
        (rest-positions (mapcar #'get-rest-places voices)) ;==> rests positions 
        (pitch-positions-without-rests (mapcar #'remove-rest-posn rest-positions notes-positions)) ;==> only notes positions
        (pitch-variables-without-rests (mapcar #'posn-match pitch-variables pitch-positions-without-rests)) ;==> only pitch/var without rests
		(all-chords ;==> list-of-lists of chords for all voices (nil for rests and lists for domains in "chords" mode)
                            (remove-if #'(lambda (x) 
                                                                   (or (not (some #'s::variable? (flat x)))
                                                                                (some #'null (remove nil (flat x)))))             
                           (mat-trans pitch-variables-all-onsets)))
		;(chords-ratios (x->dx (sort-list (remove-duplicates (flat (mapcar #'(lambda (x) (dx->x 0 (om-abs x))) ratios-domain)))))) ===> NOT IMPLEMENTED YET
		;(pitch-dur-chords (mapcar #'list all-chords chords-ratios)) ;==> lists-of-lists of chords (pitches) and durations (ratios) ===> NOT IMPLEMENTED YET
		;(pitch-dur-onset-chords (mapcar #'list all-chords chords-ratios all-onsets)) ;==> lists-of-lists of chords (pitches), durations (ratios) and onsets (ratios) ===> NOT IMPLEMENTED YET
        (pitch-onset-domain (mapcar #'(lambda (x y) (mapcar #'(lambda (input1 input2) (if (listp input1) (x-append (list input1) input2) (x-append input1 input2))) x y)) pitch-variables onsets-domain))
        (pitch-dur-onset-domain (mapcar #'(lambda (x y) (mapcar #' x-append x y)) pitch-durs-domain onsets-domain)))

 (list pitch-variables-without-rests all-chords pitch-durs-domain pitch-onset-domain pitch-dur-onset-domain 
	   pitch-variables-all-onsets chords-on-beats chords-off-beats chords-first-beats midics-domain)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ==> ALL-DOMAINS <== ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
; FIRST -> ONLY PITCH
;SECOND -> CHORDS 
;THIRD -> PITCH/DURS 
;FOURTH -> PITCH/ONSETS
;FIFTH -> PITCH/DUR/ONSET
;SIXTH -> PITCH-VARS-ALL-ONSETS (FOR MEASURES)
;SEVENTH -> CHORD-ON-BEATS
;EIGHTH -> CHORDS-OFF-BEATS
;NINTH -> CHORDS-FIRST-BEATS
;TENTH -> PITCH/DURS CHORDS ===> NOT IMPLEMENTED YET
;ELEVENTH -> PITCH/DUR/ONSET CHORDS ===> NOT IMPLEMENTED YET
;TENTH -> MIDICS DOMAIN (ALWAYS LAST-ELEM ==> FOR PROFILE CONSTRAINT)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;  =================   ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod! screamer-score-domain ((domain list)
                                   (type string) &optional n-notes)												  
    :initvals '((6000 6200 6400 6500 6700 6900 7100 7200) "notes" 3)
    :indoc '( "midics-list"  "domain-type" "number or list") 
    :doc "Formats the domain (list of midics) according to the selected type (notes or chords)."
    :menuins '((1 (("notes" "notes") ("chords" "chords"))))                        
    :icon 487
(let ((domain-object (make-instance 'score-domain)))
(if (equal type "notes")
    (set-domain-parameters (list type domain) domain-object)
   (set-domain-parameters (list type domain n-notes) domain-object))
domain-object))

(defun locked-voice? (voice)
 (let ((voice-chords (remove-duplicates (flat (mapcar #'lmidic (chords voice))))))
 (not (and (= 6000 (first voice-chords))
           (= 1 (length voice-chords))))))
		   
(defun positions (input-list input-elem) ;FROM OM-TRISTAN
  (let ((index 0) res)
    (dolist (n input-list)
      (if (equal input-elem n)  (push index res)) ;modified to equal
      (setq index (1+ index)))
    (nreverse res))) 

(defun pitch-domains (voices domains)
(let* ((locked-voices-pitch (mapcar #'(lambda (x) 
                                    (if (locked-voice? x) 
                                        (chords x) t)) voices))
         (open-voices-posn (positions locked-voices-pitch t)))
(subs-posn locked-voices-pitch open-voices-posn domains)))

(defun pitch-dur-locked (ratio chord)
 (if (< ratio 0)
     (x-append (list nil) ratio) 

 (let ((notes (lmidic chord)))
   (if (= (length notes) 1)
       (x-append notes ratio)
       (list notes ratio)))))

(defun pitch-dur-vars (ratio domain mcs-approx random?)
 (if (< ratio 0)
 (x-append (list nil) ratio)
 (cond 
  ((equal (first domain) "notes")
    (if random? 
       (x-append (om?::a-random-mc-member-ofv mcs-approx (second domain)) ratio)
       (x-append (om?::a-mc-member-ofv mcs-approx (second domain)) ratio)))
  ((equal (first domain) "chords")
    (x-append (om?::list-of-mc-chords-inv (list (third domain)) mcs-approx (second domain) random?) ratio))
 (t (progn (om-message-dialog "The number of open voices does not corresponds to the number of domains.") (om-abort))))
))

(defun pitch-dur-chords (ratios domain chord-l mcs-approx random? accumul)
(if chord-l

 (let ((one-result 
        (if (< (first ratios) 0)
            (x-append (list nil) (first ratios))
             (x-append (om?::list-of-mc-chords-inv (list (first chord-l)) mcs-approx domain random?) (first ratios)))))

   (if (null (first one-result))

       (pitch-dur-chords (cdr ratios) domain chord-l mcs-approx random? (x-append (list one-result) accumul)) 

       (pitch-dur-chords (cdr ratios) domain (cdr chord-l) mcs-approx random? (x-append (list one-result) accumul))))

 (reverse accumul))) 

(defun domain-pitch-dur (voices pitch-domains mcs-approx random?)
(mapcar #'(lambda (voice pitch-dom)
 (if (locked-voice? voice)
     (mapcar #'pitch-dur-locked (tree2ratio (tree voice)) pitch-dom)
(if (equal (first pitch-dom) "chords") 
     (if (listp (third pitch-dom)) ;==> corrected (third (first pitch-domais))) to (third pitch-dom))-21.01.2024
         (let* ((ratios (tree2ratio (tree voice)))
                  (n-chords (length (remove-if #'(lambda (x) (< x 0)) ratios)))
                  (chords-correct-length (flat (group-list (third pitch-dom) (list n-chords) 'circular)))) ;==> corrected (third (first pitch-domais))    
          (pitch-dur-chords ratios (second (first pitch-domains)) chords-correct-length mcs-approx random? nil))           
     (mapcar #'(lambda (input) 
      (pitch-dur-vars input pitch-dom mcs-approx random?)) (tree2ratio (tree voice))))

     (mapcar #'(lambda (input) 
      (pitch-dur-vars input pitch-dom mcs-approx random?)) (tree2ratio (tree voice))))
    ))
 voices pitch-domains))

(defun build-measures-domain (voices all-domains)
 (let* ((measures (mapcar #'get-measures voices))
          (measures-matrix (if (list-of-listp measures) (mat-trans measures) measures))
          (notes-length-by-measure (mat-trans (mapcar #'(lambda (m-mat) 
                                                      (if (list-of-listp measures) (mapcar #'(lambda (x) (length (flat (mapcar #'lmidic (chords x))))) m-mat) 
                                                          (length (lmidic (chords m-mat)))))
                                                    measures-matrix)))
          (pitch-domains (mapcar #'(lambda (notes-domain notes-length) (group-list notes-domain notes-length 'linear))  (first all-domains) notes-length-by-measure))
          (pitch-dur-domains (mapcar #'(lambda (notes-domain notes-length) (group-list notes-domain notes-length 'linear))  (third all-domains) notes-length-by-measure))
          (pitch-onset-domains (mapcar #'(lambda (notes-domain notes-length) (group-list notes-domain notes-length 'linear))  (fourth all-domains) notes-length-by-measure))
          (pitch-dur-onset-domains (mapcar #'(lambda (notes-domain notes-length) (group-list notes-domain notes-length 'linear))  (fifth all-domains) notes-length-by-measure))
          (chords-length-by-measure (mapcar #'(lambda (x) (length (remove-duplicates (flat  x))))
                                                       (mat-trans (loop for part in pitch-onset-domains
                                                                                  for x = (loop for measure in part 
                                                                                                      collect (mapcar #'second measure))
                                                                                 collect x))))
        (chords-all-onsets (group-list (mat-trans (sixth all-domains)) chords-length-by-measure 'linear))
        (chords-domains (loop for measure in chords-all-onsets
                                             for chords = ;(mapcar #'flat 
												 (remove-if #'(lambda (x) 
                                                              (or (not (some #'s::variable? (flat x)))
                                                                       (some #'null (remove nil (flat x))))) 
                                                  measure)
												  ;)
                                            collect chords))
		;==> PITCH-DUR-CHORDS
		;==> PITCH-DUR-ONSET-CHORDS									
        (midics-domain (last-elem all-domains)))

 (list pitch-domains chords-domains pitch-dur-domains pitch-onset-domains pitch-dur-onset-domains midics-domain)))

(defun measure-tree2ratio (mesure)
 (let* ((signature (car mesure))
          (vals (cadr mesure))
          (ratios (mesure-ratios vals)))
          (om/
           (om* ratios (car signature))
           (cadr signature))))

(defun get-measure-rest-places (measure)
 (let ((tree (list '? (list (tree measure)))))
  (get-rest-places tree)))

(defun ratios2onsets (ratios)
(butlast (dx->x 0 (om-abs ratios))))

(defun ratios2notes-posn (ratios) 
(arithm-ser 0 (1- (length ratios)) 1))

(defun posn-in-onsets-list (voice-onsets-posn all-onsets)
(posn-in-onsets-list-internal voice-onsets-posn all-onsets nil))
 
(defun posn-in-onsets-list-internal (voice-onsets-posn all-onsets accumul)
(if all-onsets
   (cond 
   ((= 1 (length (second voice-onsets-posn)) )
    (posn-in-onsets-list-internal voice-onsets-posn
                                                 (cdr all-onsets) 
                                                 (x-append (first (second voice-onsets-posn)) accumul)))

   ((< (first all-onsets) (second (first voice-onsets-posn)) )
    (posn-in-onsets-list-internal voice-onsets-posn
                                                 (cdr all-onsets) 
                                                 (x-append (first (second voice-onsets-posn)) accumul)))

  ((= (first all-onsets) (second (first voice-onsets-posn)) )
     (posn-in-onsets-list-internal (x-append (list (cdr (first voice-onsets-posn)))
                                                                  (list (cdr (second voice-onsets-posn))))
                                                 (cdr all-onsets)
                                                 (x-append (second (second voice-onsets-posn)) accumul))))  

(reverse accumul)))

(defun remove-rest-posn (rest-places positions)
 (remove-if #'(lambda (x) (member x rest-places)) positions))

(defun get-beats-from-time-sig (time-sig)
   (repeat-n (/ 1 (second time-sig))
                  (first time-sig)))

(defun get-beats-offbeats (voices all-onsets pitch-variables-all-onsets)
 (let* ((time-sig (get-time-sig (first voices)))
          (beats (mapcar #'get-beats-from-time-sig time-sig))
          (beats-length (mapcar #'length beats))
	  (first-beats-posn-posn (dx->x 0 (butlast beats-length)))
          (beats-onsets (butlast (dx->x 0 (flat beats))))
          (beats-posn (mapcar #'(lambda (x) (position x all-onsets)) beats-onsets))
	  (chords (mat-trans pitch-variables-all-onsets))
          (offbeats (remove-nth chords beats-posn))
	 (first-beats-posn (posn-match beats-posn first-beats-posn-posn)))
(list (posn-match chords beats-posn)
       offbeats
	  (posn-match chords first-beats-posn))))
	  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	  
;;;UTILS

;;;RHYTHMIC CONSTRUCTOR

(defun group-ratios (timesig puls ratios)
 (let* ((tree (mktree ratios timesig))
        (tree-groups (mapcar #'second (second tree))))
  (mapcar #'(lambda (groups pulses)
	        (group-list groups pulses 'linear))	
	tree-groups puls)
  )
 )

(defmethod! cons-tree ((timesig list) (puls list) (subdiv list) (mode string))	
   :initvals '( ( (5 8) (6 8) (6 8)) ((2 3) (2 2 2) (1)) (((1 1) (1 1 1)) ((1 1) (1 1) (1 1)) ((1.0))) "tree")
   :indoc '( "list" "list" "list" "string") 
   :menuins '((3 (("tree" "tree") ("ratio" "ratio"))))
   :doc
"Constructs a rhythmic tree from three arguments: 
(1) A list of time signatures;
(2) A list of lists of pulses subdivisions;
(3) A list of lists of beats subdivisions or a list of ratios.
"   	                   
   :icon 254
 (cond ((equal mode "tree") 
        (list '?
              (mapcar #'(lambda (tim p s)
                         (list tim
                              (mapcar #'list p s)))
               timesig puls subdiv)))
			   
		((equal mode "ratio")	  
	     (let ((ratio-subdiv (group-ratios timesig puls subdiv))) 
         (list '?
               (mapcar #'(lambda (tim p s)
                          (list tim
                               (mapcar #'list p s)))
                timesig puls ratio-subdiv))))
		 
	    (t nil)
  )	   
 )
 
(defun tree-rotations (tree)
 (let* ((ratios (tree2ratio tree))
        (timesig (get-time-sig tree))
        (rot-positions (om?::all-rotations (arithm-ser 0 (1- (length ratios)) 1)))
        (rotations (mapcar #'(lambda (pos)
                         (posn-match ratios pos)) rot-positions)))
 (mapcar #'(lambda (ratios-list)
                (mktree ratios-list timesig)) 
  rotations)))

(defmethod! cons-subdiv ((subdiv list) &optional rest-pos tie-pos)
   :initvals '( (4 3 4 6) () ())
   :indoc '( "list" "list" "list") 
   :doc
"Constructs the subdivisions of a measure.
"   	                   
   :icon 254
 (let ((beats (mapcar #'(lambda (x) (repeat-n 1 x)) subdiv))
        (rests (if (null rest-pos) (repeat-n nil (length subdiv)) rest-pos))
        (ties (if (null tie-pos) (repeat-n nil (length subdiv)) tie-pos)))
(mapcar #'(lambda (beat rests ties)
 (loop for n in beat 
          for x from 0 to (1- (length beat))
          collect (cond ((member x rests) (* -1 n))
                               ((member x ties) (float n))
                               (t n))))
beats rests ties)))