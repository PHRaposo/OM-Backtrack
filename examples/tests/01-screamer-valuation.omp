; OM File Header - Saved 2024/04/30 12:31:21
; (7.04 :patc (om-make-point 38 123) (om-make-point 14 87) (om-make-point 1152 458) "" 183 0 "2024/04/24 08:12:18" "2024/04/30 11:24:54")
; End File Header
(in-package :om)(load-lib-for (quote ("OM-Backtrack")))(setf *om-current-persistent* (om-load-patch1 "01-screamer-valuation" (quote ((let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 110 191) (om-make-point 91 30) (list 0 1 2 3 4 5) "(0 1 2 3 4 5)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "a-member-of" (om-load-patch-abs1 "a-member-of" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 72 304) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 78 9) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "A-MEMBER-OF" (quote a-member-of) (quote ((om-load-inputfun (quote input-funbox) "list of possible values" "LST" (list 0 1 2 3 4 5)))) (om-make-point 54 81) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (1 0 2 0 nil 0))) 7.04 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 73 222) nil (list (list 0 1 2 3 4 5)) nil "a-member-of"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ALL-VALUES" (quote all-values) (quote ((om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil))) (om-make-point 98 317) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "one-value" (om-load-patch-abs1 "one-value" (quote ((let ((box (om-load-boxcall (quote genfun) "ONE-VALUE" (quote one-value) (quote ((om-load-inputfun (quote input-funbox) "expressions" "EXPRESSION" nil))) (om-make-point 71 210) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 72 304) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 78 9) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "A-MEMBER-OF" (quote a-member-of) (quote ((om-load-inputfun (quote input-funbox) "list of possible values" "LST" (list 0 1 2 3 4 5)))) (om-make-point 50 119) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 0 0 nil 0) (0 0 1 0 nil 0) (2 0 3 0 nil 0))) 7.04 nil "" (om-make-point 199 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 151 87) nil (list 0) nil "one-value"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "ith-value" (om-load-patch-abs1 "ith-value" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 333 263) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ITH-VALUE" (quote ith-value) (quote ((om-load-inputfun (quote input-funbox) "integer" "I" 10) (om-load-inputfun (quote input-funbox) "forms" "FORMS" nil))) (om-make-point 330 160) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 390 0) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 287 20) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "A-MEMBER-OF" (quote a-member-of) (quote ((om-load-inputfun (quote input-funbox) "list of possible values" "LST" (list 0 1 2 3 4 5)))) (om-make-point 390 76) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (3 0 1 0 nil 0) (4 0 1 1 nil 0) (2 0 4 0 nil 0))) 7.04 nil "" (om-make-point 200 200) (om-make-point 570 399)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 441 161/2) nil (list 3) nil "ith-value"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "n-values" (om-load-patch-abs1 "n-values" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 326 295) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 340 0) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 238 36) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "A-MEMBER-OF" (quote a-member-of) (quote ((om-load-inputfun (quote input-funbox) "list of possible values" "LST" (list 0 1 2 3 4 5)))) (om-make-point 333 149/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "N-VALUES" (quote n-values) (quote ((om-load-inputfun (quote input-funbox) "integer" "N" 10) (om-load-inputfun (quote input-funbox) "forms" "FORMS" nil))) (om-make-point 291 211) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((4 0 0 0 nil 0) (1 0 3 0 nil 0) (2 0 4 0 nil 0) (3 0 4 1 nil 0))) 7.04 nil "" (om-make-point 200 200) (om-make-point 577 371)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 705/2 317/4) nil (list (list 0 1)) nil "n-values"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 117 10) (om-make-point 95 30) (list 0 1 2 3 4 5) "(0 1 2 3 4 5 )" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "print-values" (om-load-patch-abs1 "print-values" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 173 247) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 71) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "A-MEMBER-OF" (quote a-member-of) (quote ((om-load-inputfun (quote input-funbox) "list of possible values" "LST" (list 0 1 2 3 4 5)))) (om-make-point 196 50) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "PRINT-VALUES" (quote print-values) (quote ((om-load-inputfun (quote input-funbox) "forms" "FORMS" nil))) (om-make-point 214 171) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 0 0 nil 0) (1 0 2 0 nil 0) (2 0 3 0 nil 0))) 7.04 nil "" (om-make-point 200 200) (om-make-point 339 296)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 222 161/2) nil (list 5) nil "print-values"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "all-values" (om-load-patch-abs1 "all-values" (quote ((let ((box (om-load-boxcall (quote genfun) "ALL-VALUES" (quote all-values) (quote ((om-load-inputfun (quote input-funbox) "expressions" "EXPRESSIONS" nil))) (om-make-point 56 190) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 72 304) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 78 9) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "A-MEMBER-OF" (quote a-member-of) (quote ((om-load-inputfun (quote input-funbox) "list of possible values" "LST" (list 0 1 2 3 4 5)))) (om-make-point 54 81) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 0 0 nil 0) (0 0 1 0 nil 0) (2 0 3 0 nil 0))) 7.04 nil "" (om-make-point 200 200) (om-make-point 231 373)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 77 81) nil (list (list 0 1 2 3 4 5)) nil "all-values"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 452 30) (quote "EXAMPLE FROM https://www.cuemath.com/algebra/objective-function/ ") "" (om-make-point 541 31) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "best-value-example" (om-load-patch-abs1 "best-value-example" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 512 670) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "BEST-VALUE" (quote best-value) (quote ((om-load-inputfun (quote input-funbox) "integer" "FORM1" nil) (om-load-inputfun (quote input-funbox) "forms" "OBJECTIVE-FORM" nil))) (om-make-point 503 591) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "LINEAR-FORCE" (quote linear-force) (quote ((om-load-inputfun (quote input-funbox) "variable" "VARIABLE" nil))) (om-make-point 433 337) nil nil "#" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "STATIC-ORDERING" (quote static-ordering) (quote ((om-load-inputfun (quote input-funbox) "force function" "FORCE-FUNCTION" nil))) (om-make-point 347 415) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SOLUTION 2" (quote solution) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil) (om-load-inputfun (quote input-funbox) "ordering force function" "FORCE-FUNCTION" nil))) (om-make-point 313 507) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 375 346) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "SEQUENCE" (quote sequence) (quote ((om-load-inputfun (quote input-funbox) "something" "PATCH" nil) (om-load-inputfun (quote input-funbox) "more things" "OPPATCH" nil) (om-load-inputfun (quote input-funbox) "more things" "OPPATCH" nil))) (om-make-point 205 424) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "+V 3" (quote screamer:+v) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 603 311) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 9" (quote t) (quote nil) (om-make-point 653 209) (om-make-point 41 30) 100 "100" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "*V 3" (quote screamer:*v) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 620 249) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 8" (quote t) (quote nil) (om-make-point 583 205) (om-make-point 41 30) 300 "300" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "*V 2" (quote screamer:*v) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 564 243) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 7" (quote t) (quote nil) (om-make-point 261 208) (om-make-point 34 30) 60 "60" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "+V 2" (quote screamer:+v) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 223 188) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "<=V 2" (quote screamer:<=v) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 223 242) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ASSERT! 2" (quote screamer:assert!) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 214 358) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 6" (quote t) (quote nil) (om-make-point 171 261) (om-make-point 41 30) 100 "100" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 5" (quote t) (quote nil) (om-make-point 124 154) (om-make-point 27 30) 5 "5" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "*V" (quote screamer:*v) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 109 183) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "+V" (quote screamer:+v) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 124 241) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "<=V" (quote screamer:<=v) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 146 303) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ASSERT!" (quote screamer:assert!) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 137 363) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "AN-INTEGER-ABOVEV 2" (quote screamer:an-integer-abovev) (quote ((om-load-inputfun (quote input-funbox) "LOW" "LOW" nil))) (om-make-point 446 81) nil nil "&" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 387 43) (om-make-point 27 30) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "AN-INTEGER-ABOVEV" (quote screamer:an-integer-abovev) (quote ((om-load-inputfun (quote input-funbox) "LOW" "LOW" nil))) (om-make-point 259 81) nil nil "&" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (4 0 1 0 nil 0) (7 0 1 1 nil 0) (2 0 3 0 nil 0) (6 2 4 0 nil 0) (3 0 4 1 nil 0) (24 0 5 0 nil 1) (22 0 5 1 nil 2) (21 0 6 0 nil 0) (15 0 6 1 nil 0) (5 0 6 2 nil 0) (11 0 7 0 nil 0) (9 0 7 1 nil 0) (22 0 9 0 nil 2) (8 0 9 1 nil 0) (24 0 11 0 nil 1) (10 0 11 1 nil 0) (24 0 13 0 nil 1) (22 0 13 1 nil 2) (13 0 14 0 nil 0) (12 0 14 1 nil 0) (14 0 15 0 nil 0) (24 0 18 0 nil 1) (17 0 18 1 nil 0) (18 0 19 0 nil 0) (22 0 19 1 nil 2) (19 0 20 0 nil 0) (16 0 20 1 nil 0) (20 0 21 0 nil 0) (23 0 22 0 nil 0) (23 0 24 0 nil 0))) 7.04 nil "" (om-make-point 222 23) (om-make-point 826 723)) (quote nil) (om-make-point 16777/24 515/8) nil (list (list (list 10 50) 8000)) nil "best-value-example"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 410 69) (om-make-point 27 30) 3 "3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 326 72) (om-make-point 27 30) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0) (1 0 2 0 nil 0) (6 0 3 0 nil 0) (11 0 4 0 nil 0) (6 0 4 1 nil 0) (12 0 5 0 nil 0) (6 0 5 1 nil 0) (6 0 7 0 nil 0) (6 0 8 0 nil 0))) nil 7.04))
