; OM File Header - Saved 2023/05/31 16:16:42
; (7.02 :patc (om-make-point 183 250) (om-make-point 117 80) (om-make-point 412 398) "" 183 0 "2023/05/30 13:33:10" "2023/05/31 16:16:42")
; End File Header
(in-package :om)(load-lib-for (quote ("OM-Screamer")))(setf *om-current-persistent* (om-load-patch1 "08-backtrack-tut-8" (quote ((let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxcomment "comment" (om-make-point 480 240) (quote "list-of-chords-in defines a list of \"a-chords-in\", as its name say.$$The third input is optional and can be used to state constraint on$each chord. This input can deal with a single constraint (patch in$lambda-mode) or a list of constraints (list of patches in lambda-mode)$$Remark : in the \"growing bass\" patch, you'll find the \"growing?\" predicate.$There is another Screamer predefind predicate, \"alldiff?\". Both do what their$name suggest they do.$$Try to evaluate the patch woth different values for the chords' length : you'll$see the main trouble with backtracking, the calculation time increases really$fast when the number of variables increases. With (3 4 3), the first answer$arrives after 0,2 secondes, but with (3 4 3 4), the first solution arrives after$20 minutes !") nil (om-make-point 280 189) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12.0D0 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 309 45) (quote "A chord-seq where all chords contain an interval$of either 400 midic, or 700 midic.") nil (om-make-point 339 121) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12.0D0 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 66 437) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "APPLY-CONT" (quote apply-cont) (quote ((om-load-inputfun (quote input-funbox) "List of constraints in lambda-mode" "FUNS" nil) (om-load-inputfun (quote input-funbox) "Variables" "VAR" nil))) (om-make-point 46 1005/4) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "growing-bass" (om-load-patch-abs1 "growing-bass" (quote ((let ((box (om-load-boxcall (quote genfun) "GROWING?" (quote growing?) (quote ((om-load-inputfun (quote input-funbox) "a list" "L" nil))) (om-make-point 86 250) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CAR" (quote car) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 104 190) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAT-TRANS" (quote mat-trans) (quote ((om-load-inputfun (quote input-funbox) "a list of lists" "MATRIX" nil))) (om-make-point 87 108) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 91 355) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 103 24) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (2 0 1 0 nil 0) (4 0 2 0 nil 0) (0 0 3 0 nil 0))) 7.02 nil "" (om-make-point 199 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 11 613/4) nil (list nil) "l" "growing-bass"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 49 1357/4) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 8 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :fluidsynth) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 400 20) 0 1 (quote :normal) (quote t) nil)) nil nil nil nil (quote nil)))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 151 50) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 160 425) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 247 336) (om-make-point 41 30) 100 "100" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 212 375) (om-make-point 34 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 186 320) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 226 249) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low value" "FROM" 0) (om-load-inputfun (quote input-funbox) "high value" "TO" 10))) (om-make-point 270 134) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 348 57) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 123 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 215 497) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 96 494) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (3 0 2 0 nil 0) (1 0 2 1 nil 0) (7 0 3 0 nil 0) (4 0 3 1 nil 0) (5 0 4 0 nil 0) (7 0 4 1 nil 0) (7 0 5 0 nil 0) (6 0 5 1 nil 0) (0 1 8 0 nil 0) (0 0 9 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 131 16) (om-make-point 34 30) 48 "48" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 190 16) (om-make-point 34 30) 72 "72" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "400-or-700" (om-load-patch-abs1 "400-or-700" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 144 426) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NOT 2" (quote not) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 260 307) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NULL 2" (quote null) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 261 251) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NOT" (quote not) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 72 306) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NULL" (quote null) (quote ((om-load-inputfun (quote input-funbox) "X" "X" nil))) (om-make-point 73 250) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 250 140) (om-make-point 41 30) 700 "700" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 62 147) (om-make-point 41 30) 400 "400" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMOR" (quote omor) (quote ((om-load-inputfun (quote input-funbox) "something" "SELF" nil) (om-load-inputfun (quote input-funbox) "other things" "REST" nil))) (om-make-point 158 377) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MEMBER 2" (quote member) (quote ((om-load-inputfun (quote input-funbox) "ITEM" "ITEM" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 250 193) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MEMBER" (quote member) (quote ((om-load-inputfun (quote input-funbox) "ITEM" "ITEM" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 62 193) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X->DX" (quote x->dx) (quote ((om-load-inputfun (quote input-funbox) "a list of numbers" "SELF" (list 0 1)))) (om-make-point 156 95) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 163 10) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((7 0 0 0 nil 0) (2 0 1 0 nil 0) (8 0 2 0 nil 0) (4 0 3 0 nil 0) (9 0 4 0 nil 0) (3 0 7 0 nil 0) (1 0 7 1 nil 0) (5 0 8 0 nil 0) (10 0 8 1 nil 0) (6 0 9 0 nil 0) (10 0 9 1 nil 0) (11 0 10 0 nil 0))) 7.02 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 239 209/4) nil (list nil) "l" "400-or-700"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "LIST-OF-CHORDS-IN" (quote list-of-chords-in) (quote ((om-load-inputfun (quote input-funbox) "number of variables" "L" (list 4 3 2)) (om-load-inputfun (quote input-funbox) "domains" "DOM" (list 6000 6200 6400 6600 6800 7000 7200)) (om-load-inputfun (quote input-funbox) "constraints on variables" "PROV" (list 6000 6200 6400 6600 6800 7000 7200)))) (om-make-point 125 609/4) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 70 409/4) (om-make-point 70 30) (list 3 4 3 4) "(3 4 3 4)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 2 0 nil 0) (4 0 3 0 nil 0) (10 0 3 1 nil 0) (3 0 5 1 nil 0) (7 0 6 0 nil 0) (8 0 6 1 nil 0) (11 0 10 0 nil 0) (6 0 10 1 nil 0) (9 0 10 2 nil 0))) 7.02 nil "" (om-make-point 225 134) (om-make-point 805 518)) (quote nil) (om-make-point 941/9 2485/36) nil (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((4800 4900 5300) (4900 5000 5100 5500) (5000 5100 5500) (5100 5200 5400 5800))) :lonset (quote (0 1000 2000 3000 4000)) :ldur (quote ((1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000) (1000 1000 1000 1000))) :lvel (quote ((100 100 100) (100 100 100 100) (100 100 100) (100 100 100 100))) :loffset (quote ((0 0 0) (0 0 0 0) (0 0 0) (0 0 0 0))) :lchan (quote ((1 1 1) (1 1 1 1) (1 1 1) (1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0) (0 0 0 0) (0 0 0) (0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 7.02 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj)) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 47 185) (om-make-point 291 114) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((4800 4900 5300) (4900 5000 5100 5500) (5000 5100 5500) (5100 5200 5400 5800))) :lonset (quote (0 1000 2000 3000 4000)) :ldur (quote ((1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000) (1000 1000 1000 1000))) :lvel (quote ((100 100 100) (100 100 100 100) (100 100 100) (100 100 100 100))) :loffset (quote ((0 0 0) (0 0 0 0) (0 0 0) (0 0 0 0))) :lchan (quote ((1 1 1) (1 1 1 1) (1 1 1) (1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0) (0 0 0 0) (0 0 0) (0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 7.02 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 8 24 (quote gf) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :fluidsynth) 1 nil 1000 0 (om-make-point 507 282) (om-make-point 400 23) 0 1 (quote :normal) (quote t) nil)) t nil nil nil (quote nil)))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 144 45) (quote "Open the red ?patch.$") "" (om-make-point 185 89) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0))) nil 7.02))