; OM File Header - Saved 2023/07/14 23:30:29
; (7.02 :patc (om-make-point 19 103) (om-make-point 50 50) (om-make-point 774 641) "" 183 0 "2023/06/06 13:06:19" "2023/07/06 20:10:23")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "lisp-functions" (quote ((let ((box (om-load-boxcall (quote lispfun) "REVERSE" (quote reverse) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 66 307) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 461 45) (quote "This second example uses the functions funcallv, -v, assert!-all-differentv$to calculate all 3856 all-interval series. ") "" (om-make-point 235 333) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12.0D0 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "All-Interval-Series 3" (om-load-lisp-abs-nondeterpatch "All-Interval-Series" 7.02 ";;; ALL-INTERVAL SERIES ;;;$$(lambda (vars)$    (let* ((VarArray vars)$           (Intervals (mapcar #'(lambda (x y) $                            (s::funcallv #'mod (s::-v y x) 12))  VarArray (cdr VarArray)))) $$(om?::assert!-all-differentv VarArray)$$(om?::assert!-all-differentv intervals)$  $ (s::solution $  VarArray$   (s::static-ordering #'s::linear-force))))") (quote ((om-load-inputfun (quote input-funbox) "" "VARS" nil))) (om-make-point 67 556) nil (list (list 0 1 3 7 2 10 8 11 5 4 9 6)) nil "All-Interval-Series"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "A-MEMBER-OFV 3" (quote screamer:a-member-ofv) (quote ((om-load-inputfun (quote input-funbox) "VALUES" "VALUES" nil))) (om-make-point 44 353) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 11" (quote t) (quote nil) (om-make-point 18 269) (om-make-point 149 30) (list 1 2 3 4 5 7 8 9 10 11) "(1 2 3 4 5 7 8 9 10 11)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N 3" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "something" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "N" 0))) (om-make-point 97 400) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 10" (quote t) (quote nil) (om-make-point 143 364) (om-make-point 34 30) 10 "10" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND 2" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil))) (om-make-point 93 481) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 9" (quote t) (quote nil) (om-make-point 165 433) (om-make-point 27 30) 6 "6" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 8" (quote t) (quote nil) (om-make-point 48 439) (om-make-point 27 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "permutations 2" (om-load-lisp-abs-nondeterpatch "permutations" 7.02 ";;; ALL-PERMUTATIONS ;;;$$(lambda (vars)$ (let ((VarArray vars))$$(s::assert! (apply 's::/=v VarArray))$$(reverse (s::solution VarArray (s::static-ordering #'s::linear-force)))))") (quote ((om-load-inputfun (quote input-funbox) "" "VARS" nil))) (om-make-point 76 180) nil (list (list 2 0 1 3 4 5)) nil "permutations"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "A-MEMBER-OFV" (quote screamer:a-member-ofv) (quote ((om-load-inputfun (quote input-funbox) "VALUES" "VALUES" nil))) (om-make-point 55 48) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 67 2) (om-make-point 91 30) (list 0 1 2 3 4 5) "(0 1 2 3 4 5)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "something" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "N" 0))) (om-make-point 90 114) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 157 82) (om-make-point 27 30) 6 "6" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 414 180) (quote "In this library it is also possible to use functions written in lisp. $With this feature we can access screamer functions that has not $been implemented yet in the library. $$In this example we use the screamer functions a-members-ofv $(which is different from a-member-of), assert!, /=v, solution, $static-ordering and linear-force to calculate all permutations$of a given list. $$It is not necessary to include one-value, all-values or print-values$since it's alerady implemented. ") "" (om-make-point 239 3) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12.0D0 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((4 0 0 0 nil 0) (7 0 2 0 nil 0) (0 0 3 0 nil 0) (3 0 5 0 nil 0) (6 0 5 1 nil 0) (9 0 7 0 nil 0) (5 0 7 1 nil 0) (8 0 7 2 nil 0) (13 0 10 0 nil 0) (12 0 11 0 nil 0) (11 0 13 0 nil 0) (14 0 13 1 nil 0))) nil 7.02))
